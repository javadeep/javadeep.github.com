<html>
    <head>
        <title>深入理解Java虚拟机（JVM高级特性与最佳实践）</title>
        <style type="text/css">
            body {
                background-color: #d2b48c;
                margin-left: 10%;
                margin-right: 10%;
                border: 2px dotted black;
                padding: 10px 10px 10px 10px;
                font-family: sans-serif;
            }
        </style>
    </head>
    <body>
        <img height="800" width="800" src="http://img0.imgtn.bdimg.com/it/u=1708675289,3229629623&fm=21&gp=0.jpg">
        <br><br><br>
        <h1> 目录 </h1>
        <p><a href="./index.html#forword">前言</a></p>
        <p><a href="./index.html#part_1">第一部分 走近Java</a></p>
        <blockquote>
            <p><a href="./index.html#chapter_1">第1章 走近Java</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_1_1">1.1 概述</a></p>
                <p><a href="./index.html#chapter_1_2">1.2 Java技术体系</a></p>
                <p><a href="./index.html#chapter_1_3">1.3 Java发展史</a></p>
                <p><a href="./index.html#chapter_1_4">1.4 Java虚拟机发展史</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_4_1">1.4.1 Sun Classic/Exact VM</a></p>
                    <p><a href="./index.html#chapter_1_4_2">1.4.2 Sun HotSpot VM</a></p>
                    <p><a href="./index.html#chapter_1_4_3">1.4.3 Sun Mobile-Embedded VM/Meta-Circular VM</a></p>
                    <p><a href="./index.html#chapter_1_4_4">1.4.4 BEA JRockit/IBM J9 VM</a></p>
                    <p><a href="./index.html#chapter_1_4_5">1.4.5 Azul VM/BEA Liquid VM</a></p>
                    <p><a href="./index.html#chapter_1_4_6">1.4.6 Apache Harmony/Google Android Dalvik VM</a></p>
                    <p><a href="./index.html#chapter_1_4_7">1.4.7 Microsoft JVM及其他</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_1_5">1.5 展望Java技术的未来</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_5_1">1.5.1 模块化</a></p>
                    <p><a href="./index.html#chapter_1_5_2">1.5.2 混合语言</a></p>
                    <p><a href="./index.html#chapter_1_5_3">1.5.3 多核并行</a></p>
                    <p><a href="./index.html#chapter_1_5_4">1.5.4 进一步丰富语法</a></p>
                    <p><a href="./index.html#chapter_1_5_5">1.5.5 64位虚拟机</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_1_6">1.6 实战：自己编译JDK</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_6_1">1.6.1 获取JDK源码</a></p>
                    <p><a href="./index.html#chapter_1_6_2">1.6.2 系统需求</a></p>
                    <p><a href="./index.html#chapter_1_6_3">1.6.3 构建编译环境</a></p>
                    <p><a href="./index.html#chapter_1_6_4">1.6.4 进行编译</a></p>
                    <p><a href="./index.html#chapter_1_6_5">1.6.5 在IDE工具中进行源码调试</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_1_7">1.7 本章小结</a></p>
            </blockquote>
        </blockquote>
        <p><a href="./index.html#part_2">第二部分 自动内存管理机制</a></p>
        <blockquote>
            <p><a href="./index.html#chapter_2">第2章 Java内存区域与内存溢出异常</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_2_1">2.1 概述</a></p>
                <p><a href="./index.html#chapter_2_2">2.2 运行时数据区域</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_2_1">2.2.1 程序计数器</a></p>
                    <p><a href="./index.html#chapter_2_2_2">2.2.2 Java虚拟机栈</a></p>
                    <p><a href="./index.html#chapter_2_2_3">2.2.3 本地方法栈</a></p>
                    <p><a href="./index.html#chapter_2_2_4">2.2.4 Java堆</a></p>
                    <p><a href="./index.html#chapter_2_2_5">2.2.5 方法区</a></p>
                    <p><a href="./index.html#chapter_2_2_6">2.2.6 运行时常量池 </a></p>
                    <p><a href="./index.html#chapter_2_2_7">2.2.7 直接内存 </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_2_3">2.3 HotSpot虚拟机对象探秘</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_3_1">2.3.1 对象的创建</a></p>
                    <p><a href="./index.html#chapter_2_3_2">2.3.2 对象的内存布局</a></p>
                    <p><a href="./index.html#chapter_2_3_3">2.3.3 对象的访问定位</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_2_4">2.4 实战：OutOfMemoryError异常</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_4_1">2.4.1 Java堆溢出</a></p>
                    <p><a href="./index.html#chapter_2_4_2">2.4.2 虚拟机栈和本地方法栈溢出</a></p>
                    <p><a href="./index.html#chapter_2_4_3">2.4.3 方法区和运行时常量池溢出</a></p>
                    <p><a href="./index.html#chapter_2_4_4">2.4.4 本机直接内存溢出 </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_2_5">2.5 本章小结</a></p>
            </blockquote>
            <p><a href="./index.html#chapter_3">第3章 垃圾收集器与内存分配策略</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_3_1">3.1 概述</a></p>
                <p><a href="./index.html#chapter_3_2">3.2 对象已死吗 </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_3_2_1">3.2.1 引用计数算法</a></p>
                    <p><a href="./index.html#chapter_3_2_2">3.2.2 可达性分析算法</a></p>
                    <p><a href="./index.html#chapter_3_2_3">3.2.3 再谈引用</a></p>
                    <p><a href="./index.html#chapter_3_2_4">3.2.4 生存还是死亡 </a></p>
                    <p><a href="./index.html#chapter_3_2_5">3.2.5 回收方法区 </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_3_3">3.3 垃圾收集算法 </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_3_3_1">3.3.1 标记-清除算法 </a></p>
                    <p><a href="./index.html#chapter_3_3_2">3.3.2 复制算法 </a></p>
                    <p><a href="./index.html#chapter_3_3_3">3.3.3 标记-整理算法 </a></p>
                    <p><a href="./index.html#chapter_3_3_4">3.3.4 分代收集算法 </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_3_4">3.4 HotSpot的算法实现 </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_3_4_1">3.4.1 枚举根节点 </a></p>
                    <p><a href="./index.html#chapter_3_4_2">3.4.2 安全点 </a></p>
                    <p><a href="./index.html#chapter_3_4_3">3.4.3 安全区域 </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_3_5">3.5 垃圾收集器 </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_3_5_1">3.5.1 Serial收集器 </a></p>
                    <p><a href="./index.html#chapter_3_5_2">3.5.2 ParNew收集器 </a></p>
                    <p><a href="./index.html#chapter_3_5_3">3.5.3 Parallel Scavenge收集器 </a></p>
                    <p><a href="./index.html#chapter_3_5_4">3.5.4 Serial Old收集器 </a></p>
                    <p><a href="./index.html#chapter_3_5_5">3.5.5 Parallel Old收集器 </a></p>
                    <p><a href="./index.html#chapter_3_5_6">3.5.6 CMS收集器 </a></p>
                    <p><a href="./index.html#chapter_3_5_7">3.5.7 G1收集器 </a></p>
                    <p><a href="./index.html#chapter_3_5_8">3.5.8 理解GC日志 </a></p>
                    <p><a href="./index.html#chapter_3_5_9">3.5.9 垃圾收集器参数总结 </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_3_6">3.6 内存分配与回收策略 </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_3_6_1">3.6.1 对象优先在Eden分配 </a></p>
                    <p><a href="./index.html#chapter_3_6_2">3.6.2 大对象直接进入老年代 </a></p>
                    <p><a href="./index.html#chapter_3_6_3">3.6.3 长期存活的对象将进入老年代 </a></p>
                    <p><a href="./index.html#chapter_3_6_4">3.6.4 动态对象年龄判定 </a></p>
                    <p><a href="./index.html#chapter_3_6_5">3.6.5 空间分配担保 </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_3_7">3.7 本章小结 </a></p> 
            </blockquote>
            <p><a href="./index.html#chapter_4">第4章 虚拟机性能监控与故障处理工具</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_4_1">4.1 概述 </a></p>
                <p><a href="./index.html#chapter_4_2">4.2 JDK的命令行工具 </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_4_2_1">4.2.1 jps：虚拟机进程状况工具 </a></p>
                </blockquote>
            </blockquote>
        </blockquote>
        <br><br><br>
        <h1 id="forword">前言</h1>
        <p> 在绝大多数情况下，提升硬件效能无法等比例地提升程序的运作性能和并发能力，甚至可能对程序运作状况完全没有任何改善。原因有：</p>
        <ul>
            <li> Java虚拟机原因：为了达到给所有硬件提供一致的虚拟平台的目的，牺牲了一些与硬件相关的性能特性。</li>
            <li> 更重要的认为原因：如果开发人员不了解虚拟机一些技术特性的运行原理，就无法写出最适合虚拟机运行和自优化的代码。</li>
        </ul>
        <br><br>
        <h2> 第2版与第1版的区别 </h2>
        <p> 本书的第二版把讲解的技术平台从JDK 1.6提升到JDK 1.7。</p>
        <br><br>
        <h2> 本书面向的读者 </h2>
        <ol>
            <li> 使用Java技术体系的中、高级开发人员 </li>
            <li> 系统调优师 </li>
            <li> 系统架构师 </li>
        </ol>
        <br><br>
        <h2> 如何阅读本书 </h2>
        <p> 亲自实践，代码清单下载地址：<a href="http://www.hzbook.com">http://www.hzbook.com</a>。</p>
        <br><br>
        <h2> 勘误与支持 </h2>
        <p> 本书第2版的勘误，将会在作者的博客：<a href="http://icyfenix.iteye.com/">http://icyfenix.iteye.com/</a>中发布。</p>
        <br><br>
        <h2> 致谢 </h2>
        <br><br><br>
        <h1 id="part_1"> 第一部分 走近Java </h1>
        <p><a href="./index.html#chapter_1">第1章 走近Java</a></p>
        <br><br><br>
        <h1 id="chapter_1"> 第1章 走近Java </h1>
        <p> 世界上没有完美的程序，写程序本身就是一个不断追求完美的过程。</p>
        <br><br>
        <h2 id="chapter_1_1">1.1 概述</h2>
        <p> Java优点：</p>
        <ul>
            <li> 摆脱硬件平台的束缚，<q>一次编写，到处运行</q>。 </li>
            <li> 提供一个相对安全的内存管理和访问机制，避免了绝大部分的内存泄露和指针越界问题。</li>
            <li> 实现了热点代码检测和运行时编译及优化，使Java应用能随着运行时间的增加而获得更高的性能。</li>
            <li> 有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库来帮助它实现各种各样的功能。</li>
        </ul>
        <br><br>
        <h2 id="chapter_1_2"> 1.2 Java技术体系 </h2>
        <p> 传统意义上看，包括以下几个组成部分：</p>
        <ul>
            <li> Java程序设计语言 </li>
            <li> 各种硬件平台上的Java虚拟机 </li>
            <li> Class文件格式 </li>
            <li> Java API类库 </li>
            <li> 来自商业机构和开源社区的第三方Java类库 </li>
        </ul>
        <img src="http://www.2cto.com/uploadfile/2013/0618/20130618043314158.jpg">
        <p> 按照Java技术关注的重点业务领域来划分，Java技术体系可以分为4个平台：</p>
        <ul>
            <li> Java Card：支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台。</li>
            <li> Java ME（Micro Edition）：支持Java程序运行在移动终端（手机、PDA）上的平台（J2ME）。</li>
            <li> Java SE（Standard Edition）：支持面向桌面级应用的Java平台，提供完整的Java核心API（J2SE）。</li>
            <li> Java EE（Enterprise Edition）：支持使用多层架构的企业应用的Java平台（J2EE）。</li>
        </ul>
        <br><br>
        <h2 id="chapter_1_3"> 1.3 Java发展史 </h2>
        <img src="http://s3.51cto.com/wyfs01/M01/0F/50/wKioJlG_8Dry9ZIjAABXzJc8-XY324.jpg">
        <br><br>
        <h2 id="chapter_1_4"> 1.4 Java虚拟机发展史 </h2>
        <br>
        <h3 id="chapter_1_4_1"> 1.4.1 Sun Classic/Exact VM </h3>
        <p> 世界上第一款商用Java虚拟机。 </p>
        <br>
        <h3 id="chapter_1_4_2"> 1.4.2 Sun HotSpot VM </h3>
        <p> Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。 </p>
        <br>
        <h3 id="chapter_1_4_3"> 1.4.3 Sun Mobile-Embedded Vm/Meta-Circular VM </h3>
        <br>
        <h3 id="chapter_1_4_4"> 1.4.4 BEA JRockit/IBM J9 VM </h3>
        <br>
        <h3 id="chapter_1_4_5"> 1.4.5 Azul VM/BEA Liquid VM </h3>
        <br>
        <h3 id="chapter_1_4_6"> 1.4.6 Apache Harmony/Google Android Dalvik VM </h3>
        <br>
        <h3 id="chapter_1_4_7"> 1.4.7 Microsoft JVM及其他 </h3>
        <br><br>
        <h2 id="chapter_1_5"> 1.5 展望Java技术的未来 </h2>
        <p><q>Java技术下一个十年</q></p>
        <br>
        <h3 id="chapter_1_5_1"> 1.5.1 模块化 </h3>
        <p> 模块化是解决应用系统与技术平台越来越复杂、越来越庞大问题的一个重要途径。</p>
        <br>
        <h3 id="chapter_1_5_2"> 1.5.2 混合语言 </h3>
        <p> 当单一的Java开发已经无法满足当前软件的复杂需求时，越来越多基于Java虚拟机的语言开发被应用到软件项目中，Java平台上的多语言混合编程正成为主流，每种语言都可以针对自己擅长的方面更好地解决问题。</p>
        <br>
        <h3 id="chapter_1_5_3"> 1.5.3 多核并行 </h3>
        <p> 如今，CPU硬件的发展方向已经从高频率转变为多核心，随着多核时代的来临，软件开发越来越关注并行编程的领域。</p>
        <br>
        <h3 id="chapter_1_5_4"> 1.5.4 进一步丰富语法 </h3>
        <br>
        <h3 id="chapter_1_5_5"> 1.5.5 64位虚拟机 </h3>
        <p> 随着硬件的进一步发展，计算机终究会完全过渡到64位的时代，这是一件毫无疑问的事情，主流的虚拟机应用也终究会从32位发展至64位，而虚拟机对64位的支持也将会进一步完善。</p>
        <br><br>
        <h2 id="chapter_1_6"> 1.6 实战：自己编译JDK </h2>
        <p> 选择OpenJDK进行编译 </p>
        <br>
        <h3 id="chapter_1_6_1"> 1.6.1 获取JDK源码 </h3>
        <p> OpenJDK 7和Oracle JDK 7在程序上是非常接近的，两者共用了大量相同的代码。</p>
        <br>
        <h3 id="chapter_1_6_2"> 1.6.2 系统需求 </h3>
        <p> 尽量在Linux、MacOS或Solaris上构建OpenJDK，这要比在Windows平台上容易得多。</p>
        <br>
        <h3 id="chapter_1_6_3"> 1.6.3 构建编译环境 </h3>
        <p> 对于Mac OS，需要安装最新版本的Xcode和Command Line Tools for Xcode。</p>
        <br>
        <h3 id="chapter_1_6_4"> 1.6.4 进行编译 </h3>
        <br>
        <h3 id="chapter_1_6_5"> 1.6.5 在IDE工具中进行源码调试 </h3>
        <br><br>
        <h2 id="chapter_1_7"> 1.7 本章小结 </h2>
        <br><br><br>
        <h1 id="part_2"> 第二部分 自动内存管理机制 </h1>
        <p><a href="./index.html#chapter_2">第2章 Java内存区域与内存溢出异常</a></p>
        <p><a href="./index.html#chapter_3">第3章 垃圾收集器与内存分配策略</a></p>
        <br><br><br>
        <h1 id="chapter_2"> 第2章 Java内存区域与内存溢出异常 </h1>
        <br><br>
        <h2 id="chapter_2_1"> 2.1 概述 </h2>
        <p> Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄露和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。</p>
        <br><br>
        <h2 id="chapter_2_2"> 2.2 运行时数据区域 </h2>
        <img width = "758" height = "603" src = "http://dl2.iteye.com/upload/attachment/0085/5209/394db105-6281-3753-aa77-f3087515e21d.jpg">
        <br>
        <h3 id="chapter_2_2_1"> 2.2.1 程序计数器 </h3>
        <p> 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p>
        <p> 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为<q>线程私有</q>的内存。</p>
        <p> 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有任何OutOfMemoryError情况的区域。</p>
        <br>
        <h3 id="chapter_2_2_2"> 2.2.2 Java虚拟机栈 </h3>
        <p> 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。</p>
        <p> 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链表、方法出口等信息。</p>
        <p> 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用。</p>
        <p> 其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。</p>
        <p> 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
        <p> 在Java虚拟机规范中，对这个区域规定了两种异常状况：</p>
        <ul>
            <li> 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</li>
            <li> 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li>
        </ul>
        <br>
        <h3 id="chapter_2_2_3"> 2.2.3 本地方法栈 </h3>
        <p> 本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p>
        <p> 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
        <br>
        <h3 id="chapter_2_2_4"> 2.2.4 Java堆 </h3>
        <p> Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
        <p> Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作<q>GC堆</q>（Garbage Collected Heap）。</p>
        <p> 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。</p>
        <p> 当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
        <br>
        <h3 id="chapter_2_2_5"> 2.2.5 方法区 </h3>
        <p> 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
        <p> 一般来说，这个区域的回收<q>成绩</q>比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。</p>
        <p> 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
        <br>
        <h3 id="chapter_2_2_6"> 2.2.6 运行时常量池 </h3>
        <p> 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
        <p> 运行时常量池相对于Class文件常量池的另外一个重要特性是具备动态性，Java语言不要求常量一定只有编译期才能产生。</p>
        <br>
        <h3 id="chapter_2_2_7"> 2.2.7 直接内存 </h3>
        <p> 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>
        <br><br>
        <h2 id="chapter_2_3"> 2.3 HotSpot虚拟机对象探秘 </h2>
        <p> 以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p>
        <br>
        <h3 id="chapter_2_3_1"> 2.3.1 对象的创建 </h3>
        <p> 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
        <blockquote>
            <p> 除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p>
            <ul>
                <li> 对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方法保证更新操作的原子性；</li>
                <li> 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</li>
            </ul>
        </blockquote>
        <p> 在类加载检查通过后，接下来虚拟机将为心声对象分配内存，如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。</p>
        <p> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</p>
        <p> 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p>
        <p> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始——&lt;init&gt;方法还没有执行，所有的字段都还为零。所以一般来说，执行new指令之后会接着执行&lt;init&gt;方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
        <br>
        <h3 id="chapter_2_3_2"> 2.3.2 对象的内存布局 </h3>
        <p> 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。</p>
        <p> HotSpot虚拟机的对象头包括两部分信息：</p>
        <ul>
            <li> 第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。官方称其为<q>Mark Word</q>。</li>
            <li> 第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</li>
        </ul>
        <p> 接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p>
        <p> 对其填充并不是必然存在的，也有没特别的含义，它仅仅起着占位符的作用。</p>
        <br>
        <h3 id="chapter_2_3_3"> 2.3.3 对象的访问定位 </h3>
        <p> Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种：</p>
        <ul>
            <li> 
                如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。<br>
                <img src="http://s8.51cto.com/wyfs01/M00/0F/51/wKioJlG_-Inhdj7hAABexy3NVLM916.jpg">
            </li>
            <li>
                如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。<br>
                <img src="http://s5.51cto.com/wyfs01/M01/0F/51/wKioJlG_-ImiIwiAAABfwPwRjpY164.jpg">
            </li>
        </ul>
        <p> 这两种对象访问方式各有优势：</p>
        <ul>
            <li> 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</li>
            <li> 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。HotSpot是使用第二种方式进行对象访问的。</li>
        </ul>
        <br><br>
        <h2 id="chapter_2_4"> 2.4 实战：OutOfMemoryError异常 </h2>
        <br>
        <h3 id="chapter_2_4_1"> 2.4.1 Java堆溢出 </h3>
        <p> 通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。</p>
        <p> Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息<q>java.lang.OutOfMemoryError</q>会跟着进一步提示<q>Java heap space</q>。</p>
        <br>
        <h3 id="chapter_2_4_2"> 2.4.2 虚拟机栈和本地方法栈溢出 </h3>
        <p> 由于在HotSpot虚拟机中不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p>
        <ul>
            <li> 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li>
            <li> 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li>
        </ul>
        <p> 在单个线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。</p>
        <p> 通过不断地建立线程的方式可以产生内存溢出异常。在这种情况下，为每个线程的栈分配的内容越大，反而越容易产生内存溢出异常。每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。</p>
        <p> 如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。</p>
        <p> 如果是建立过多线程导致的内存溢出，异常堆栈信息<q>java.lang.OutOfMemoryError</q>会跟着进一步提示<q>unable to create new native thread</q>。</p>
        <br>
        <h3 id="chapter_2_4_3"> 2.4.3 方法区和运行时常量池溢出 </h3>
        <p> 我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小。</p>
        <p> 运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是<q>PermGen space</q>，说明运行时常量池属于方法区的一部分。</p>
        <p> 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。</p>
        <p> 方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。</p>
        <br>
        <h3 id="chapter_2_4_4"> 2.4.4 本机直接内存溢出 </h3>
        <p> DirectMemory容量可以通过-XX: MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样。</p>
        <p> 由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p>
        <br><br>
        <h2 id="chapter_2_5"> 2.5 本章小结 </h2>
        <p> 虽然Java有垃圾收集机制，但内存溢出异常离我们仍然并不遥远。</p>
        <br><br><br>
        <h1 id="chapter_3"> 第3章 垃圾收集器与内存分配策略 </h1>
        <br><br>
        <h2 id="chapter_3_1"> 3.1 概述 </h2>
        <p> 目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入了<q>自动化</q>时代，但当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些<q>自动化</q>的技术实施必要的监控和调节。</p>
        <br><br>
        <h2 id="chapter_3_2"> 3.2 对象已死吗 </h2>
        <br>
        <h3 id="chapter_3_2_1"> 3.2.1 引用计数算法 </h3>
        <p> 主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。</p>
        <br>
        <h3 id="chapter_3_2_2"> 3.2.2 可达性分析算法 </h3>
        <p> 通过一系列的称为<q>GC Roots</q>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
        <img src="http://img1.imgtn.bdimg.com/it/u=2069212403,2747155386&fm=11&gp=0.jpg">
        <p> 在Java语言中，可作为GC Roots的对象包括： </p>
        <ul>
            <li> 虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
            <li> 方法区中类静态属性引用的对象。</li>
            <li> 方法区中常量引用的对象。</li>
            <li> 本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
        </ul>
        <br>
        <h3 id="chapter_3_2_3"> 3.2.3 再谈引用 </h3>
        <ul>
            <li> 强引用：程序代码中普遍存在的，类似<q>Object obj = new Object()</q>这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
            <li> 软引用：还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。JDK提供了SoftReference类来实现软引用。</li>
            <li> 弱引用：也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。JDK提供了WeakReference类来实现弱引用。 </li>
            <li> 虚引用：最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。JDK提供了PhantomReference类来实现虚引用。 </li>
        </ul>
        <br>
        <h3 id="chapter_3_2_4"> 3.2.4 生存还是死亡 </h3>
        <p> 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况视为<q>没有必要执行</q>。</p>
        <p> 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的<q>执行</q>是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。</p>
        <p> finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时。</p>
        <h3 id="chapter_3_2_5"> 3.2.5 回收方法区 </h3>
        <p> 在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾收集效率远低于此。</p>
        <p> 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p>
        <p> 在大量使用反射、动态代理、CGLib等ByteCode框架，动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备卸载的功能，以保证永久代不会溢出。</p>
        <br><br>
        <h2 id="chapter_3_3"> 3.3 垃圾收集算法 </h2>
        <br>
        <h3 id="chapter_3_3_1"> 3.3.1 标记—清除算法 </h3>
        <p> 算法分为<q>标记</q>和<q>清除</q>两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
        <p> 不足： </p>
        <ul>
            <li> 效率问题：标记和清除两个过程的效率都不高。</li>
            <li> 空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
        </ul>
        <img height="336" width="600" src="http://img3.imgtn.bdimg.com/it/u=4272436537,1502591496&fm=15&gp=0.jpg">
        <br>
        <h3 id="chapter_3_3_2"> 3.3.2 复制算法 </h3>
        <p> 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
        <p> 代价：将内存缩小为了原来的一半，太高了。</p>
        <img src="http://www.jayfeng.com/images/gc_mark_compact.png">
        <p> 新生代中的对象98%是<q>朝生夕死</q>的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>
        <p> HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。</p>
        <p> 内存的分配担保：如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>
        <br>
        <h3 id="chapter_3_3_3"> 3.3.3 标记-整理算法 </h3>
        <p> 老年代一般不能直接选用复制收集算法。</p>
        <p> 根据老年代的特点，提出了<q>标记-整理</q>算法，标记过程仍然与<q>标记-清除</q>算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p>
        <img width="501" height="309" src="http://img4.imgtn.bdimg.com/it/u=3931507371,1198982255&fm=21&gp=0.jpg">
        <br>
        <h3 id="chapter_3_3_4"> 3.3.4 分代收集算法 </h3>
        <p> 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。</p>
        <p> 老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<q>标记-清理</q>或者<q>标记-整理</q>算法来进行回收。</p> 
        <br><br>
        <h2 id="chapter_3_4"> 3.4 HotSpot的算法实现 </h2>
        <br>
        <h3 id="chapter_3_4_1"> 3.4.1 枚举根节点 </h3>
        <p> 在HotSpot的实现中，使用一组称为OopMap的数据结构来直接得知哪些地方存放着对象引用。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p>
        <br>
        <h3 id="chapter_3_4_2"> 3.4.2 安全点 </h3>
        <p> HotSpot没有为每条指令都生成OapMap，只是在<q>特定的位置</q>记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。</p>
        <p> 如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都<q>都</q>到最近的安全点上再停顿下来？</p>
        <ul>
            <li> 抢先式中断（Preemptive Suspension）：不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它<q>跑</q>到安全点上（现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件）</li>
            <li> 主动式中断（Voluntary Suspension）：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li>
        </ul>
        <br>
        <h3 id="chapter_3_4_3"> 3.4.3 安全区域 </h3>
        <p> 安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p>
        <p> 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，在当这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
        <br><br>
        <h2 id="chapter_3_5"> 3.5 垃圾收集器 </h2>
        <p> 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
        <img width="600" height="463" src="http://img0.imgtn.bdimg.com/it/u=2213618683,1531995707&fm=21&gp=0.jpg">
        <p> 如果两个收集器之间存在连线，就说明它们可以搭配使用。</p>
        <br>
        <h3 id="chapter_3_5_1"> 3.5.1 Serial收集器 </h3>
        <p> 单线程收集器，但并不仅仅只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。又称<q>Stop The World</q>。</p>
        <p> Serial/Serial Old收集器运行示意图：</p>
        <img src="http://www.51cto.com/files/uploadimg/20110727/133301626.jpg">
        <p> Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p>
        <br>
        <h3 id="chapter_3_5_2"> 3.5.2 ParNew收集器 </h3>
        <p> ParNew收集器其实就是Serial收集器的多线程版本。</p>
        <p> ParNew/Serial Old收集器运行示意图：</p>
        <img src="http://image76.360doc.com/DownloadImg/2014/07/2520/43724306_3.jpg">
        <p> 除了Serial收集器外，目前只有ParNew能与CMS收集器配合工作。</p>
        <p> ParNew收集器在单CPU的环境下绝对不会有比Serial收集器更好的效果。但随着可以使用的CPU数量的增加，它对于GC时系统资源的有效利用还是很有好处的。</p>
        <br>
        <h3 id="chapter_3_5_3"> 3.5.3 Parallel Scavenge收集器 </h3>
        <p> Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。如虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。Parallel Scavenge收集器也经常称为<q>吞吐量优先</q>收集器。</p>
        <p> Parallel Scavenge收集器有一个参数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmm）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。</p>
        <p> 自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p>
        <br>
        <h3 id="chapter_3_5_4"> 3.5.4 Serial Old收集器 </h3>
        <p> Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用<q>标记-整理</q>算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。</p>
        <p> Serial/Serial Old收集器运行示意图：</p>
        <img src="http://www.51cto.com/files/uploadimg/20110727/133301626.jpg">
        <br>
        <h3 id="chapter_3_5_5"> 3.5.5 Parallel Old收集器 </h3>
        <p> Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和<q>标记-整理</q>算法。</p>
        <p> 在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p>
        <p> Parallel Scavenge/Parallel Old收集器运行示意图：</p>
        <img src="http://img1.imgtn.bdimg.com/it/u=1881419748,2096715655&fm=21&gp=0.jpg">
        <br>
        <h3 id="chapter_3_5_6"> 3.5.6 CMS收集器 </h3>
        <p> CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
        <p> CMS收集器是基于<q>标记-清除</q>算法实现的，整个过程分为4个步骤：</p>
        <ul>
            <li> 初始标记 </li>
            <li> 并发标记 </li>
            <li> 重新标记 </li>
            <li> 并发清除 </li>
        </ul>
        <p> 其中，初始标记、重新标记这两个步骤仍然需要<q>Stop The World</q>。</p>
        <p> 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。</p>
        <p> 并发标记阶段就是进行GC Roots Tracing的过程。</p>
        <p> 重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
        <p> 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
        <p> Concurrent Mark Sweep收集器运行示意图：</p>   
        <img src="http://img1.imgtn.bdimg.com/it/u=3633202708,3349028389&fm=15&gp=0.jpg">
        <p> CMS主要优点：并发收集、并发停顿，也称为并发停顿收集器（Concurrent Low Pause Collector）。</p>
        <p> 缺点：</p>
        <ul>
            <li> CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。</li>
            <li> CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现<q>Concurrent Mode Failure</q>失败而导致另一次Full GC的产生。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次<q>Concurrent Mode Failure</q>失败，这时虚拟机将启动后背预案：临时启动Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li>
            <li> CMS是一款基于<q>标记-清除</q>算法实现的收集器，收集结束时会有大量空间碎片产生。如果无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</li>
        </ul>
        <br>
        <h3 id="chapter_3_5_7"> 3.5.7 G1收集器 </h3>
        <P> G1(Garbage-First)是一款面向服务器应用的垃圾收集器。与其他GC收集器相比，G1具备如下特点：</p>
        <ul>
            <li> 并行与并发 </li>
            <li> 分代收集 </li>
            <li> 空间整合 </li>
            <li> 可预测的停顿 </li>
        </ul>
        <p> G1收集器运行示意图：</p>
        <img src ="http://img4.imgtn.bdimg.com/it/u=3015395405,4048127103&fm=21&gp=0.jpg">
        <br>
        <h3 id="chapter_3_5_8"> 3.5.8 理解GC日志 </h3>
        <blockquote>
            33.125: [GC [DefNew: 3324K->152K(3712K), 0.0025925 secs] 3324K->152K(11904K), 0.0031680 secs] <br> 
            100.667: [Full GC [Tenured: 0K->210K(10240K), 0.0149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] <br>  
        </blockquote>
        <ul>
            <li> 最前面的数字<q>33.125: </q>和<q>100.667: </q>代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</li>
            <li> GC日志开头的<q>[GC</q>和<q>[Full GC</q>说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有<q>Full</q>，说明这次GC是发生了Stop-The-World的。</li>
            <li> 接下来的<q>[DefNew</q>、<q>[Tenured</q>、<q>[Perm</q>表示GC发生的区域。</li>
            <li> 后面方括号内部的<q>3324K-&gt;152K(3712K)</q>含义是<q>GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）</q>。</li>
            <li> 在方括号之外的<q>3324K-&gt;152K(11904K)</q>表示<q>GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）</q>。</li>
            <li> 再往后，<q>0.0025925 secs</q>表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如：<q>[Times: user=0.01 sys=0.00, real=0.02 secs]</q>。</li>
        </ul>
        <br>
        <h3 id="chapter_3_5_9"> 3.5.9 垃圾收集器参数总结 </h3>
        <img src="http://s1.51cto.com/wyfs01/M00/0F/58/wKioOVHAWOqBO7arAAE3eO_kODg253.jpg">
        <img src="http://s1.51cto.com/wyfs01/M01/0F/56/wKioJlHAWOqSXjwoAACetjhPaCY983.jpg">
        <br><br>
        <h2 id="chapter_3_6"> 3.6 内存分配与回收策略 </h2>
        <br>
        <h3 id="chapter_3_6_1"> 3.6.1 对象优先在Eden分配 </h3>
        <p> 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
        <p> 虚拟机提供了-XX:PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。</p>
        <p> Minor GC和Full GC区别：</p>
        <ul>
            <li> 新生代GC(Minor GC)：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li>
            <li> 老年代GC(Major GC/Full GC)：指发生在老年代的GC。Major GC的速度一般会比Minor GC慢10倍以上。</li>
        </ul>
        <br>
        <h3 id="chapter_3_6_2"> 3.6.2 大对象直接进入老年代 </h3>
        <p> 打对象指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</p>
        <p> 比遇到一个大对象更加坏的消息就是遇到一群<q>朝生夕灭</q>的<q>短命大对象</q>，写程序的时候应当避免。</p>
        <p> 经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来<q>安置</q>它们。</p>
        <p> 虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>
        <p> PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数。</p>
        <br>
        <h3 id="chapter_3_6_3"> 3.6.3 长期存活的对象将进入老年代 </h3>
        <p> 对象在Survivor区中每<q>熬过</q>一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。</p>
        <br>
        <h3 id="chapter_3_6_4"> 3.6.4 动态对象年龄判定 </h3>
        <p> 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
        <h3 id="chapter_3_6_5"> 3.6.5 空间分配担保 </h3>
        <p> 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p>
        <p> 如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure），那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。</p>
        <p> JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p>
        <br><br>
        <h2 id="chapter_3_7"> 3.7 本章小结 </h2>
        <br><br><br>
        <h1 id="chapter_4"> 第4章 虚拟机性能监控与故障处理工具 </h1>
        <br><br>
        <h2 id="chapter_4_1"> 4.1 概述 </h2>
        <p> 给定一个系统定位问题的时候，只是、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。这里说的数据包括：运行日志、异常堆栈、GC日志、线程快照（threaddump/javacore文件）、堆转储快照（headdump/hprof文件）等。</p>
        <br><br>
        <h2 id="chapter_4_2"> 4.2 JDK的命令行工具 </h2>
        <br>
        <h3 id="chapter_4_2_1"> 4.2.1 jps：虚拟机进程状况工具 </h3>
        <blockquote>
            jps -l <br>
        </blockquote>
        <p> 可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier，LVMID）。</p>
        <p> LVMID与操作系统的进程ID（Process Identifier，PID）是一致的。</p>
        <p> jps工具主要选项：</p>
        <ul>
            <li> -q：只输出LVMID，省略主类的名称 </li>
            <li> -m：输出虚拟机进程启动时传递给主类main()函数的参数 </li>
            <li> -l：输出主类的全名，如果进程执行的是jar包，输出Jar路径 </li>
            <li> -v：输出虚拟机进程启动时JVM参数 </li>
        </ul>
    </body>
</html>