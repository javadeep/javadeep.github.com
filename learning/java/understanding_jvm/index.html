<html>
    <head>
        <title>深入理解Java虚拟机（JVM高级特性与最佳实践）</title>
        <style type="text/css">
            body {
                background-color: #d2b48c;
                margin-left: 10%;
                margin-right: 10%;
                border: 2px dotted black;
                padding: 10px 10px 10px 10px;
                font-family: sans-serif;
            }
        </style>
    </head>
    <body>
        <img height="800" width="800" src="http://img0.imgtn.bdimg.com/it/u=1708675289,3229629623&fm=21&gp=0.jpg">
        <br><br><br>
        <h1> 目录 </h1>
        <p><a href="./index.html#forword">前言</a></p>
        <p><a href="./index.html#part_1">第一部分 走近Java</a></p>
        <blockquote>
            <p><a href="./index.html#chapter_1">第1章 走近Java</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_1_1">1.1 概述</a></p>
                <p><a href="./index.html#chapter_1_2">1.2 Java技术体系</a></p>
                <p><a href="./index.html#chapter_1_3">1.3 Java发展史</a></p>
                <p><a href="./index.html#chapter_1_4">1.4 Java虚拟机发展史</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_4_1">1.4.1 Sun Classic/Exact VM</a></p>
                    <p><a href="./index.html#chapter_1_4_2">1.4.2 Sun HotSpot VM</a></p>
                    <p><a href="./index.html#chapter_1_4_3">1.4.3 Sun Mobile-Embedded VM/Meta-Circular VM</a></p>
                    <p><a href="./index.html#chapter_1_4_4">1.4.4 BEA JRockit/IBM J9 VM</a></p>
                    <p><a href="./index.html#chapter_1_4_5">1.4.5 Azul VM/BEA Liquid VM</a></p>
                    <p><a href="./index.html#chapter_1_4_6">1.4.6 Apache Harmony/Google Android Dalvik VM</a></p>
                    <p><a href="./index.html#chapter_1_4_7">1.4.7 Microsoft JVM及其他</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_1_5">1.5 展望Java技术的未来</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_5_1">1.5.1 模块化</a></p>
                    <p><a href="./index.html#chapter_1_5_2">1.5.2 混合语言</a></p>
                    <p><a href="./index.html#chapter_1_5_3">1.5.3 多核并行</a></p>
                    <p><a href="./index.html#chapter_1_5_4">1.5.4 进一步丰富语法</a></p>
                    <p><a href="./index.html#chapter_1_5_5">1.5.5 64位虚拟机</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_1_6">1.6 实战：自己编译JDK</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_6_1">1.6.1 获取JDK源码</a></p>
                    <p><a href="./index.html#chapter_1_6_2">1.6.2 系统需求</a></p>
                    <p><a href="./index.html#chapter_1_6_3">1.6.3 构建编译环境</a></p>
                    <p><a href="./index.html#chapter_1_6_4">1.6.4 进行编译</a></p>
                    <p><a href="./index.html#chapter_1_6_5">1.6.5 在IDE工具中进行源码调试</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_1_7">1.7 本章小结</a></p>
            </blockquote>
        </blockquote>
        <p><a href="./index.html#part_2">第二部分 自动内存管理机制</a></p>
        <blockquote>
            <p><a href="./index.html#chapter_2">第2章 Java内存区域与内存溢出异常</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_2_1">2.1 概述</a></p>
                <p><a href="./index.html#chapter_2_2">2.2 运行时数据区域</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_2_1">2.2.1 程序计数器</a></p>
                    <p><a href="./index.html#chapter_2_2_2">2.2.2 Java虚拟机栈</a></p>
                    <p><a href="./index.html#chapter_2_2_3">2.2.3 本地方法栈</a></p>
                    <p><a href="./index.html#chapter_2_2_4">2.2.4 Java堆</a></p>
                    <p><a href="./index.html#chapter_2_2_5">2.2.5 方法区</a></p>
                    <p><a href="./index.html#chapter_2_2_6">2.2.6 运行时常量池 </a></p>
                    <p><a href="./index.html#chapter_2_2_7">2.2.7 直接内存 </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_2_3">2.3 HotSpot虚拟机对象探秘</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_3_1">2.3.1 对象的创建</a></p>
                    <p><a href="./index.html#chapter_2_3_2">2.3.2 对象的内存布局</a></p>
                </blockquote>
            </blockquote>
        </blockquote>
        <br><br><br>
        <h1 id="forword">前言</h1>
        <p> 在绝大多数情况下，提升硬件效能无法等比例地提升程序的运作性能和并发能力，甚至可能对程序运作状况完全没有任何改善。原因有：</p>
        <ul>
            <li> Java虚拟机原因：为了达到给所有硬件提供一致的虚拟平台的目的，牺牲了一些与硬件相关的性能特性。</li>
            <li> 更重要的认为原因：如果开发人员不了解虚拟机一些技术特性的运行原理，就无法写出最适合虚拟机运行和自优化的代码。</li>
        </ul>
        <br><br>
        <h2> 第2版与第1版的区别 </h2>
        <p> 本书的第二版把讲解的技术平台从JDK 1.6提升到JDK 1.7。</p>
        <br><br>
        <h2> 本书面向的读者 </h2>
        <ol>
            <li> 使用Java技术体系的中、高级开发人员 </li>
            <li> 系统调优师 </li>
            <li> 系统架构师 </li>
        </ol>
        <br><br>
        <h2> 如何阅读本书 </h2>
        <p> 亲自实践，代码清单下载地址：<a href="http://www.hzbook.com">http://www.hzbook.com</a>。</p>
        <br><br>
        <h2> 勘误与支持 </h2>
        <p> 本书第2版的勘误，将会在作者的博客：<a href="http://icyfenix.iteye.com/">http://icyfenix.iteye.com/</a>中发布。</p>
        <br><br>
        <h2> 致谢 </h2>
        <br><br><br>
        <h1 id="part_1"> 第一部分 走近Java </h1>
        <p><a href="./index.html#chapter_1">第1章 走近Java</a></p>
        <br><br><br>
        <h1 id="chapter_1"> 第1章 走近Java </h1>
        <p> 世界上没有完美的程序，写程序本身就是一个不断追求完美的过程。</p>
        <br><br>
        <h2 id="chapter_1_1">1.1 概述</h2>
        <p> Java优点：</p>
        <ul>
            <li> 摆脱硬件平台的束缚，<q>一次编写，到处运行</q>。 </li>
            <li> 提供一个相对安全的内存管理和访问机制，避免了绝大部分的内存泄露和指针越界问题。</li>
            <li> 实现了热点代码检测和运行时编译及优化，使Java应用能随着运行时间的增加而获得更高的性能。</li>
            <li> 有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库来帮助它实现各种各样的功能。</li>
        </ul>
        <br><br>
        <h2 id="chapter_1_2"> 1.2 Java技术体系 </h2>
        <p> 传统意义上看，包括以下几个组成部分：</p>
        <ul>
            <li> Java程序设计语言 </li>
            <li> 各种硬件平台上的Java虚拟机 </li>
            <li> Class文件格式 </li>
            <li> Java API类库 </li>
            <li> 来自商业机构和开源社区的第三方Java类库 </li>
        </ul>
        <img src="http://www.2cto.com/uploadfile/2013/0618/20130618043314158.jpg">
        <p> 按照Java技术关注的重点业务领域来划分，Java技术体系可以分为4个平台：</p>
        <ul>
            <li> Java Card：支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台。</li>
            <li> Java ME（Micro Edition）：支持Java程序运行在移动终端（手机、PDA）上的平台（J2ME）。</li>
            <li> Java SE（Standard Edition）：支持面向桌面级应用的Java平台，提供完整的Java核心API（J2SE）。</li>
            <li> Java EE（Enterprise Edition）：支持使用多层架构的企业应用的Java平台（J2EE）。</li>
        </ul>
        <br><br>
        <h2 id="chapter_1_3"> 1.3 Java发展史 </h2>
        <img src="http://s3.51cto.com/wyfs01/M01/0F/50/wKioJlG_8Dry9ZIjAABXzJc8-XY324.jpg">
        <br><br>
        <h2 id="chapter_1_4"> 1.4 Java虚拟机发展史 </h2>
        <br>
        <h3 id="chapter_1_4_1"> 1.4.1 Sun Classic/Exact VM </h3>
        <p> 世界上第一款商用Java虚拟机。 </p>
        <br>
        <h3 id="chapter_1_4_2"> 1.4.2 Sun HotSpot VM </h3>
        <p> Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。 </p>
        <br>
        <h3 id="chapter_1_4_3"> 1.4.3 Sun Mobile-Embedded Vm/Meta-Circular VM </h3>
        <br>
        <h3 id="chapter_1_4_4"> 1.4.4 BEA JRockit/IBM J9 VM </h3>
        <br>
        <h3 id="chapter_1_4_5"> 1.4.5 Azul VM/BEA Liquid VM </h3>
        <br>
        <h3 id="chapter_1_4_6"> 1.4.6 Apache Harmony/Google Android Dalvik VM </h3>
        <br>
        <h3 id="chapter_1_4_7"> 1.4.7 Microsoft JVM及其他 </h3>
        <br><br>
        <h2 id="chapter_1_5"> 1.5 展望Java技术的未来 </h2>
        <p><q>Java技术下一个十年</q></p>
        <br>
        <h3 id="chapter_1_5_1"> 1.5.1 模块化 </h3>
        <p> 模块化是解决应用系统与技术平台越来越复杂、越来越庞大问题的一个重要途径。</p>
        <br>
        <h3 id="chapter_1_5_2"> 1.5.2 混合语言 </h3>
        <p> 当单一的Java开发已经无法满足当前软件的复杂需求时，越来越多基于Java虚拟机的语言开发被应用到软件项目中，Java平台上的多语言混合编程正成为主流，每种语言都可以针对自己擅长的方面更好地解决问题。</p>
        <br>
        <h3 id="chapter_1_5_3"> 1.5.3 多核并行 </h3>
        <p> 如今，CPU硬件的发展方向已经从高频率转变为多核心，随着多核时代的来临，软件开发越来越关注并行编程的领域。</p>
        <br>
        <h3 id="chapter_1_5_4"> 1.5.4 进一步丰富语法 </h3>
        <br>
        <h3 id="chapter_1_5_5"> 1.5.5 64位虚拟机 </h3>
        <p> 随着硬件的进一步发展，计算机终究会完全过渡到64位的时代，这是一件毫无疑问的事情，主流的虚拟机应用也终究会从32位发展至64位，而虚拟机对64位的支持也将会进一步完善。</p>
        <br><br>
        <h2 id="chapter_1_6"> 1.6 实战：自己编译JDK </h2>
        <p> 选择OpenJDK进行编译 </p>
        <br>
        <h3 id="chapter_1_6_1"> 1.6.1 获取JDK源码 </h3>
        <p> OpenJDK 7和Oracle JDK 7在程序上是非常接近的，两者共用了大量相同的代码。</p>
        <br>
        <h3 id="chapter_1_6_2"> 1.6.2 系统需求 </h3>
        <p> 尽量在Linux、MacOS或Solaris上构建OpenJDK，这要比在Windows平台上容易得多。</p>
        <br>
        <h3 id="chapter_1_6_3"> 1.6.3 构建编译环境 </h3>
        <p> 对于Mac OS，需要安装最新版本的Xcode和Command Line Tools for Xcode。</p>
        <br>
        <h3 id="chapter_1_6_4"> 1.6.4 进行编译 </h3>
        <br>
        <h3 id="chapter_1_6_5"> 1.6.5 在IDE工具中进行源码调试 </h3>
        <br><br>
        <h2 id="chapter_1_7"> 1.7 本章小结 </h2>
        <br><br><br>
        <h1 id="part_2"> 第二部分 自动内存管理机制 </h1>
        <p><a href="./index.html#chapter_2">第2章 Java内存区域与内存溢出异常</a></p>
        <br><br><br>
        <h1 id="chapter_2"> 第2章 Java内存区域与内存溢出异常 </h1>
        <br><br>
        <h2 id="chapter_2_1"> 2.1 概述 </h2>
        <p> Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄露和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。</p>
        <br><br>
        <h2 id="chapter_2_2"> 2.2 运行时数据区域 </h2>
        <img width = "758" height = "603" src = "http://dl2.iteye.com/upload/attachment/0085/5209/394db105-6281-3753-aa77-f3087515e21d.jpg">
        <br>
        <h3 id="chapter_2_2_1"> 2.2.1 程序计数器 </h3>
        <p> 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p>
        <p> 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为<q>线程私有</q>的内存。</p>
        <p> 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有任何OutOfMemoryError情况的区域。</p>
        <br>
        <h3 id="chapter_2_2_2"> 2.2.2 Java虚拟机栈 </h3>
        <p> 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。</p>
        <p> 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链表、方法出口等信息。</p>
        <p> 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用。</p>
        <p> 其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。</p>
        <p> 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
        <p> 在Java虚拟机规范中，对这个区域规定了两种异常状况：</p>
        <ul>
            <li> 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</li>
            <li> 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li>
        </ul>
        <br>
        <h3 id="chapter_2_2_3"> 2.2.3 本地方法栈 </h3>
        <p> 本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p>
        <p> 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
        <br>
        <h3 id="chapter_2_2_4"> 2.2.4 Java堆 </h3>
        <p> Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
        <p> Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作<q>GC堆</q>（Garbage Collected Heap）。</p>
        <p> 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。</p>
        <p> 当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
        <br>
        <h3 id="chapter_2_2_5"> 2.2.5 方法区 </h3>
        <p> 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
        <p> 一般来说，这个区域的回收<q>成绩</q>比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。</p>
        <p> 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
        <br>
        <h3 id="chapter_2_2_6"> 2.2.6 运行时常量池 </h3>
        <p> 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
        <p> 运行时常量池相对于Class文件常量池的另外一个重要特性是具备动态性，Java语言不要求常量一定只有编译期才能产生。</p>
        <br>
        <h3 id="chapter_2_2_7"> 2.2.7 直接内存 </h3>
        <p> 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>
        <br><br>
        <h2 id="chapter_2_3"> 2.3 HotSpot虚拟机对象探秘 </h2>
        <p> 以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p>
        <br>
        <h3 id="chapter_2_3_1"> 2.3.1 对象的创建 </h3>
        <p> 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
        <blockquote>
            <p> 除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p>
            <ul>
                <li> 对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方法保证更新操作的原子性；</li>
                <li> 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</li>
            </ul>
        </blockquote>
        <p> 在类加载检查通过后，接下来虚拟机将为心声对象分配内存，如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。</p>
        <p> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。</p>
        <p> 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p>
        <p> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始——&lt;init&gt;方法还没有执行，所有的字段都还为零。所以一般来说，执行new指令之后会接着执行&lt;init&gt;方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
        <br>
        <h3 id="chapter_2_3_2"> 2.3.2 对象的内存布局 </h3>
        <p> 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。</p>
        <p> HotSpot虚拟机的对象头包括两部分信息：</p>
        <ul>
            <li> 第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。官方称其为<q>Mark Word</q>。</li>
            <li> 第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</li>
        </ul>
        <p> 接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p>
        <p> 对其填充并不是必然存在的，也有没特别的含义，它仅仅起着占位符的作用。</p>
    </body>
</html>