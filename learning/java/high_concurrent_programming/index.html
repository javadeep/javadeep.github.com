<html>
    <head>
        <title>实战Java高并发程序设计</title>
        <style type="text/css">
            body {
                background-color: #d2b48c;
                margin-left: 10%;
                margin-right: 10%;
                border: 2px dotted black;
                padding: 10px 10px 10px 10px;
                font-family: sans-serif;
            }
        </style>
    </head>
    <body>
        <img width="500" height="666" src="http://img3.imgtn.bdimg.com/it/u=3432214517,2629535198&fm=15&gp=0.jpg">
        <br><br><br>
        <h1> 目录 </h1>

        <blockquote>
            <p><a href="./index.html#chapter_1">第1章 走近并行世界</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_1_1">1.1 何去何从的并行计算</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_1_1">1.1.1 忘掉那该死的并行</a></p>
                    <p><a href="./index.html#chapter_1_1_2">1.1.2 可怕的现实：摩尔定律的失效</a></p>
                    <p><a href="./index.html#chapter_1_1_3">1.1.3 柳暗花明：不断地前进</a></p>
                    <p><a href="./index.html#chapter_1_1_4">1.1.4 光明或是黑暗</a></p>
            	</blockquote>
                <p><a href="./index.html#chapter_1_2">1.2 你必须知道的几个概念</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_2_1">1.2.1 同步（Synchronous）和异步（Asynchronous）</a></p>
                    <p><a href="./index.html#chapter_1_2_2">1.2.2 并发（Concurrency）和并行（Parallelism）</a></p>
                    <p><a href="./index.html#chapter_1_2_3">1.2.3 临界区</a></p>
                    <p><a href="./index.html#chapter_1_2_4">1.2.4 阻塞（Blocking）和非阻塞（Non-Blocking） </a></p>
                    <p><a href="./index.html#chapter_1_2_5">1.2.5 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock） </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_1_3">1.3 并发级别 </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_3_1">1.3.1 阻塞（Blocking）</a></p>
                    <p><a href="./index.html#chapter_1_3_2">1.3.2 无饥饿（Starvaion-Free）</a></p>
                    <p><a href="./index.html#chapter_1_3_3">1.3.3 无障碍（Obstruction-Free）</a></p>
                    <p><a href="./index.html#chapter_1_3_4">1.3.4 无锁（Lock-Free）</a></p>
                    <p><a href="./index.html#chapter_1_3_5">1.3.5 无等待（Wait-Free）</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_1_4">1.4 有关并行的两个重要定律 </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_4_1">1.4.1 Amdahl定律 </a></p>
                    <p><a href="./index.html#chapter_1_4_2">1.4.2 Gustafson定律 </a></p>
                    <p><a href="./index.html#chapter_1_4_3">1.4.3 Amdahl定律和Gustafson定律是否相互矛盾 </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_1_5">1.5 回到Java：JMM </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_5_1">1.5.1 原子性（Atomicity） </a></p>
                    <p><a href="./index.html#chapter_1_5_2">1.5.2 可见性（Visibility） </a></p>
                    <p><a href="./index.html#chapter_1_5_3">1.5.3 有序性（Ordering） </a></p>
                    <p><a href="./index.html#chapter_1_5_4">1.5.4 哪些指令不能重排：Happen-Before规则 </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_1_6">1.6 参考文献 </a></p>
            </blockquote>
        </blockquote>
        <br><br><br>
        <h1 id="chapter_1">第1章 走入并行世界</h1>
        <br><br>
        <h2 id="chapter_1_1"> 1.1 何去何从的并行计算 </h2>
        <br>
        <h3 id="chapter_1_1_1"> 1.1.1 忘掉那该死的并行 </h3>
        <p> 并行计算只有在图像处理和服务器编程2个领域可以使用，并且它在这2个领域确实有着大量广泛的使用。</p>
        <br>
        <h3 id="chapter_1_1_2"> 1.1.2 可怕的现实：摩尔定律的失效 </h3>
        <p> 摩尔定律在CPU的计算性能上可能已经失效。CPU主频的提升已经明显遇到了一些暂时不可逾越的瓶颈。</p>
        <br>
        <h3 id="chapter_1_1_3"> 1.1.3 柳暗花明：不断地前进 </h3>
        <p> 多核CPU </p>
        <br>
        <h3 id="chapter_1_1_4"> 1.1.4 光明或是黑暗 </h3>
        <p> 如何让多个CPU有效并且正确地工作也就成为了一门技术，甚至是很大的学问。</p>
        <br><br>
        <h2 id="chapter_1_2"> 1.2 你必须知道的几个概念 </h2>
        <br>
        <h3 id="chapter_1_2_1"> 1.2.1 同步（Synchronous）和异步（Asynchronous） </h3>
        <p> 同步和异步通常用来形容一次方法调用。</p>
        <p> 同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续行为。</p>
        <p> 异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法通常会在另外一个线程中<q>真实</q>地执行。</p>
        <br>
        <h3 id="chapter_1_2_2"> 1.2.2 并发（Concurrency）和并行（Parallelism） </h3>
        <p> 并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的<q>同时执行</q>。</p>
        <br>
        <h3 id="chapter_1_2_3"> 1.2.3 临界区 </h3>
        <p> 临界区用来表示一种公共资源或者是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。</p>
        <p> 在并行程序中，临界区资源是保护的对象。</p>
        <br>
        <h3 id="chapter_1_2_4"> 1.2.4 阻塞（Blocking）和非阻塞（Non-Blocking） </h3>
        <p> 阻塞和非阻塞通常用来形容多线程间的相互影响。</p>
        <p> 一个线程占用了临界区资源，那么其他所有需要这个资源的线程必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。</p>
        <p> 非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行。</p>
        <br>
        <h3 id="chapter_1_2_5"> 1.2.5 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock） </h3>
        <p> 死锁、饥饿和活锁都属于多线程的活跃性问题。如果发现上述几种情况，那么相关线程可能就不再活跃，也就说它可能很难再继续往下执行了。</p>
        <p> 死锁是最糟糕的一种情况。</p>
        <p> 饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。</p>
        <p> 如果线程的智力不够，且都秉承这<q>谦让</q>的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行。这种情况就是活锁。</p>
        <br><br>
        <h2 id="chapter_1_3"> 1.3 并发级别 </h2>
        <p> 由于临界区的存在，多线程之间的并发必须受到控制。根据控制并发的策略，我们可以把并发的级别进行分类，大致上可以分为阻塞、无饥饿、无障碍、无锁、无等待几种。</p>
        <br>
        <h3 id="chapter_1_3_1"> 1.3.1 阻塞（Blocking） </h3>
        <p> 一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。当我们使用synchronized关键字，或者重入锁时，我们得到的就是阻塞的线程。</p>
        <p> 无论是synchronized或者重入锁，都会试图在执行后续代码前，得到临界区的锁，如果得不到，线程就会被挂起等待，直到占有了所需资源为止。</p>
        <br>
        <h3 id="chapter_1_3_2"> 1.3.2 无饥饿（Starvation-Free） </h3>
        <p> 对于非公平的锁来说，系统允许高优先级的线程插队。这样有可能导致低优先级线程产生饥饿。</p>
        <p> 如果锁是公平的，满足先来后到，那么饥饿就不会产生。</p>
        <br>
        <h3 id="chapter_1_3_3"> 1.3.3 无障碍（Obstruction-Free） </h3>
        <p> 无障碍是一种最弱的非阻塞调度。两个线程如果是无障碍的执行，那么他们不会因为临界区的问题导致一方被挂起。一旦检测到大家一起修改共享数据，它就立即对自己所做的修改进行回滚，确保数据安全。但如果没有数据竞争发生，那么线程就可以顺利完成自己的工作，走出临界区。</p>
        <p> 一种可行的无障碍实现可以依赖一个<q>一致性标记</q>来实现。线程在操作之前，先读取并保存这个标记，在操作完成后，再次读取，检查这个标记是否被更改过，如果两者是一致的，则说明资源访问没有冲突。如果不一致，则说明资源可能在操作过程中与其他写线程冲突，需要重试操作。</p>
        <br>
        <h3 id="chapter_1_3_4"> 1.3.4 无锁（Lock-Free) </h3>
        <p> 无锁的并行都是无障碍的。在无锁的情况下，所有的线程都能尝试对临界区进行访问，但不同的是，无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区。</p>
        <p> 无锁的示意代码：</p>
        <blockquote>
            while (!atomicVar.compareAndSet(localVar, localVar+1)) { <br>
            <blockquote>
                localVar = atomicVar.get(); <br>
            </blockquote>
            } <br>
        </blockquote>
        <br>
        <h3 id="chapter_1_3_5"> 1.3.5 无等待（Wait-Free) </h3>
        <p> 无锁只要求有一个线程可以在有限步内完成操作，而无等待则在无锁的基础上更进一步进行扩展。它要求所有的线程都必须在有限步内完成，这样就不会引起饥饿问题。</p>
        <p> 一种典型的无等待结构就是RCU（Read-Copy-Upate）。它的基本思想是，对数据的读可以不加控制。因此，所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。但在写数据的时候，先取得原始数据的副本，接着只修改副本数据（这就是为什么读可以不加控制），修改完成后，在合适的时机回写数据。</p>
        <br><br>
        <h2 id="chapter_1_4"> 1.4 有关并行的两个重要定律 </h2>
        <p> 使用并行程序的两个母的：</p>
        <ul>
            <li> 第一，为了获取更好的性能；</li>
            <li> 第二，由于业务模型的需要，确实需要多个执行实体。</li>
        </ul>
        <br>
        <h3 id="chapter_1_4_1"> 1.4.1 Amdahl定律 </h3>
        <p> 加速比定义：加速比 = 优化前系统耗时 / 优化后系统耗时。加速比越高，表明优化效果越明显。 </p>
        <p> 根据Amdahl定律，使用多核CPU对系统进行优化，优化的效果取决于CPU的数量以及系统中的串行化程序的比重。CPU数量越多，串行化比重越低，则优化效果越好。仅提高CPU数量而不降低程序的串行化比重，也无法提高系统性能。</p>
        <br>
        <h3 id="chapter_1_4_2"> 1.4.2 Gustafson定律 </h3>
        <p> 从Gustafson定律中，我们可以更容易地发现，如果串行化比例很小，并行化比例很大，那么加速比就是处理器的个数。只要你不断地累加处理器，就能获得更快的速度。</p>
        <br>
        <h3 id="chapter_1_4_3"> 1.4.3 Amdahl定律和Gustafson定律是否相互矛盾 </h3>
        <p> 这两个定律并不矛盾。从极端角度来说，如果系统中没有可被串行化的代码（即F=1），那么对于这两个定律，其加速比都是1。反之，如果系统中可串行化代码比重达到100%，那么这两个定律得到的加速比都是n（处理器个数）。</p>
        <br><br>
        <h2 id="chapter_1_5"> 1.5 回到Java：JMM </h2>
        <p> Java内存模型（JMM）</p>
        <p> JMM的关键技术点都是围绕着多线程的原子性、可见性和有序性来建立的。</p>
        <br>
        <h3 id="chapter_1_5_1"> 1.5.1 原子性（Atomicity）</h3>
        <p> 原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
        <p> 对于32位系统来说，long型数据的读写不是原子性的。如果两个线程同时对long进行写入的话（或者读取），对线程之间的结果是有干扰的。</p>
        <br>
        <h3 id="chapter_1_5_2"> 1.5.2 可见性（Visibility）</h3>
        <p> 可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。</p>
        <p> 除了缓存优化或者硬件优化会导致可见性问题外，指令重排以及编译器的优化，都有可能导致一个线程的修改不会立即被其他线程察觉。</p>
        <br>
        <h3 id="chapter_1_5_3"> 1.5.3 有序性（Ordering）</h3>
        <p> 有序性问题的原因是因为程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。</p>
        <p> 指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。</p>
        <p> ALU指算数逻辑单元。它是CPU的执行单元，是CPU的核心组成部分，主要功能是进行二进制算术运算。</p>
        <p> 之所以需要做指令重排，就是为了尽量少的中断流水线。</p>
        <p> 指令重排对于提高CPU处理性能是十分必要的。</p>
        <br>
        <h3 id="chapter_1_5_4"> 1.5.4 哪些指令不能重排：Happen-Before规则</h3>
        <p> 以下基本原则是指令重排不可违背的：</p>
        <ul>
            <li> 程序顺序原则：一个线程内保证语义的串行性 </li>
            <li> volatile规则：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。这保证了volatile变量的可见性。</li>
            <li> 锁规则：如果对一个锁解锁后，再加锁，那么加锁的动作绝对不能重排到解锁动作之前。</li>
            <li> 传递性：A先于B，B先于C，那么A必然先于C。</li>
            <li> 线程的start()方法先于它的每一个动作。</li>
            <li> 线程的所有操作先于线程的终结（Thread.join()）。</li>
            <li> 线程的中断（interrupt()）先于被中断线程的代码（不运行中断之后的代码）。</li>
            <li> 对象的构造函数执行、结束先于finalize()方法，。</li>
        </ul>
        <br><br>
        <h2 id="chapter_1_6"> 1.6 参考文献 </h2>
    </body>
</html>