<html>
    <head>
        <title>实战Java高并发程序设计</title>
        <style type="text/css">
            body {
                background-color: #d2b48c;
                margin-left: 10%;
                margin-right: 10%;
                border: 2px dotted black;
                padding: 10px 10px 10px 10px;
                font-family: sans-serif;
            }
        </style>
    </head>
    <body>
        <img width="500" height="666" src="http://img3.imgtn.bdimg.com/it/u=3432214517,2629535198&fm=15&gp=0.jpg">
        <br><br><br>
        <h1> 目录 </h1>

        <blockquote>
            <p><a href="./index.html#chapter_1">第1章 走近并行世界</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_1_1">1.1 何去何从的并行计算</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_1_1">1.1.1 忘掉那该死的并行</a></p>
                    <p><a href="./index.html#chapter_1_1_2">1.1.2 可怕的现实：摩尔定律的失效</a></p>
                    <p><a href="./index.html#chapter_1_1_3">1.1.3 柳暗花明：不断地前进</a></p>
                    <p><a href="./index.html#chapter_1_1_4">1.1.4 光明或是黑暗</a></p>
            	</blockquote>
                <p><a href="./index.html#chapter_1_2">1.2 你必须知道的几个概念</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_2_1">1.2.1 同步（Synchronous）和异步（Asynchronous）</a></p>
                    <p><a href="./index.html#chapter_1_2_2">1.2.2 并发（Concurrency）和并行（Parallelism）</a></p>
                    <p><a href="./index.html#chapter_1_2_3">1.2.3 临界区</a></p>
                    <p><a href="./index.html#chapter_1_2_4">1.2.4 阻塞（Blocking）和非阻塞（Non-Blocking） </a></p>
                    <p><a href="./index.html#chapter_1_2_5">1.2.5 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock） </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_1_3">1.3 并发级别 </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_3_1">1.3.1 阻塞（Blocking）</a></p>
                    <p><a href="./index.html#chapter_1_3_2">1.3.2 无饥饿（Starvaion-Free）</a></p>
                    <p><a href="./index.html#chapter_1_3_3">1.3.3 无障碍（Obstruction-Free）</a></p>
                    <p><a href="./index.html#chapter_1_3_4">1.3.4 无锁（Lock-Free）</a></p>
                    <p><a href="./index.html#chapter_1_3_5">1.3.5 无等待（Wait-Free）</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_1_4">1.4 有关并行的两个重要定律 </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_4_1">1.4.1 Amdahl定律 </a></p>
                    <p><a href="./index.html#chapter_1_4_2">1.4.2 Gustafson定律 </a></p>
                    <p><a href="./index.html#chapter_1_4_3">1.4.3 Amdahl定律和Gustafson定律是否相互矛盾 </a></p>
                </blockquote>
            </blockquote>
        </blockquote>
        <br><br><br>
        <h1 id="chapter_1">第1章 走入并行世界</h1>
        <br><br>
        <h2 id="chapter_1_1"> 1.1 何去何从的并行计算 </h2>
        <br>
        <h3 id="chapter_1_1_1"> 1.1.1 忘掉那该死的并行 </h3>
        <p> 并行计算只有在图像处理和服务器编程2个领域可以使用，并且它在这2个领域确实有着大量广泛的使用。</p>
        <br>
        <h3 id="chapter_1_1_2"> 1.1.2 可怕的现实：摩尔定律的失效 </h3>
        <p> 摩尔定律在CPU的计算性能上可能已经失效。CPU主频的提升已经明显遇到了一些暂时不可逾越的瓶颈。</p>
        <br>
        <h3 id="chapter_1_1_3"> 1.1.3 柳暗花明：不断地前进 </h3>
        <p> 多核CPU </p>
        <br>
        <h3 id="chapter_1_1_4"> 1.1.4 光明或是黑暗 </h3>
        <p> 如何让多个CPU有效并且正确地工作也就成为了一门技术，甚至是很大的学问。</p>
        <br><br>
        <h2 id="chapter_1_2"> 1.2 你必须知道的几个概念 </h2>
        <br>
        <h3 id="chapter_1_2_1"> 1.2.1 同步（Synchronous）和异步（Asynchronous） </h3>
        <p> 同步和异步通常用来形容一次方法调用。</p>
        <p> 同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续行为。</p>
        <p> 异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法通常会在另外一个线程中<q>真实</q>地执行。</p>
        <br>
        <h3 id="chapter_1_2_2"> 1.2.2 并发（Concurrency）和并行（Parallelism） </h3>
        <p> 并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的<q>同时执行</q>。</p>
        <br>
        <h3 id="chapter_1_2_3"> 1.2.3 临界区 </h3>
        <p> 临界区用来表示一种公共资源或者是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。</p>
        <p> 在并行程序中，临界区资源是保护的对象。</p>
        <br>
        <h3 id="chapter_1_2_4"> 1.2.4 阻塞（Blocking）和非阻塞（Non-Blocking） </h3>
        <p> 阻塞和非阻塞通常用来形容多线程间的相互影响。</p>
        <p> 一个线程占用了临界区资源，那么其他所有需要这个资源的线程必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。</p>
        <p> 非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行。</p>
        <br>
        <h3 id="chapter_1_2_5"> 1.2.5 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock） </h3>
        <p> 死锁、饥饿和活锁都属于多线程的活跃性问题。如果发现上述几种情况，那么相关线程可能就不再活跃，也就说它可能很难再继续往下执行了。</p>
        <p> 死锁是最糟糕的一种情况。</p>
        <p> 饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。</p>
        <p> 如果线程的智力不够，且都秉承这<q>谦让</q>的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行。这种情况就是活锁。</p>
        <br><br>
        <h2 id="chapter_1_3"> 1.3 并发级别 </h2>
        <p> 由于临界区的存在，多线程之间的并发必须受到控制。根据控制并发的策略，我们可以把并发的级别进行分类，大致上可以分为阻塞、无饥饿、无障碍、无锁、无等待几种。</p>
        <br>
        <h3 id="chapter_1_3_1"> 1.3.1 阻塞（Blocking） </h3>
        <p> 一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。当我们使用synchronized关键字，或者重入锁时，我们得到的就是阻塞的线程。</p>
        <p> 无论是synchronized或者重入锁，都会试图在执行后续代码前，得到临界区的锁，如果得不到，线程就会被挂起等待，直到占有了所需资源为止。</p>
        <br>
        <h3 id="chapter_1_3_2"> 1.3.2 无饥饿（Starvation-Free） </h3>
        <p> 对于非公平的锁来说，系统允许高优先级的线程插队。这样有可能导致低优先级线程产生饥饿。</p>
        <p> 如果锁是公平的，满足先来后到，那么饥饿就不会产生。</p>
        <br>
        <h3 id="chapter_1_3_3"> 1.3.3 无障碍（Obstruction-Free） </h3>
        <p> 无障碍是一种最弱的非阻塞调度。两个线程如果是无障碍的执行，那么他们不会因为临界区的问题导致一方被挂起。一旦检测到大家一起修改共享数据，它就立即对自己所做的修改进行回滚，确保数据安全。但如果没有数据竞争发生，那么线程就可以顺利完成自己的工作，走出临界区。</p>
        <p> 一种可行的无障碍实现可以依赖一个<q>一致性标记</q>来实现。线程在操作之前，先读取并保存这个标记，在操作完成后，再次读取，检查这个标记是否被更改过，如果两者是一致的，则说明资源访问没有冲突。如果不一致，则说明资源可能在操作过程中与其他写线程冲突，需要重试操作。</p>
        <br>
        <h3 id="chapter_1_3_4"> 1.3.4 无锁（Lock-Free) </h3>
        <p> 无锁的并行都是无障碍的。在无锁的情况下，所有的线程都能尝试对临界区进行访问，但不同的是，无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区。</p>
        <p> 无锁的示意代码：</p>
        <blockquote>
            while (!atomicVar.compareAndSet(localVar, localVar+1)) { <br>
            <blockquote>
                localVar = atomicVar.get(); <br>
            </blockquote>
            } <br>
        </blockquote>
        <br>
        <h3 id="chapter_1_3_5"> 1.3.5 无等待（Wait-Free) </h3>
        <p> 无锁只要求有一个线程可以在有限步内完成操作，而无等待则在无锁的基础上更进一步进行扩展。它要求所有的线程都必须在有限步内完成，这样就不会引起饥饿问题。</p>
        <p> 一种典型的无等待结构就是RCU（Read-Copy-Upate）。它的基本思想是，对数据的读可以不加控制。因此，所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。但在写数据的时候，先取得原始数据的副本，接着只修改副本数据（这就是为什么读可以不加控制），修改完成后，在合适的时机回写数据。</p>
        <br><br>
        <h2 id="chapter_1_4"> 1.4 有关并行的两个重要定律 </h2>
        <p> 使用并行程序的两个母的：</p>
        <ul>
            <li> 第一，为了获取更好的性能；</li>
            <li> 第二，由于业务模型的需要，确实需要多个执行实体。</li>
        </ul>
        <br>
        <h3 id="chapter_1_4_1"> 1.4.1 Amdahl定律 </h3>
        <p> 加速比定义：加速比 = 优化前系统耗时 / 优化后系统耗时。加速比越高，表明优化效果越明显。 </p>
        <p> 根据Amdahl定律，使用多核CPU对系统进行优化，优化的效果取决于CPU的数量以及系统中的串行化程序的比重。CPU数量越多，串行化比重越低，则优化效果越好。仅提高CPU数量而不降低程序的串行化比重，也无法提高系统性能。</p>
        <br>
        <h3 id="chapter_1_4_2"> 1.4.2 Gustafson定律 </h3>
        <p> 从Gustafson定律中，我们可以更容易地发现，如果串行化比例很小，并行化比例很大，那么加速比就是处理器的个数。只要你不断地累加处理器，就能获得更快的速度。</p>
        <br>
        <h3 id="chapter_1_4_3"> 1.4.3 Amdahl定律和Gustafson定律是否相互矛盾 </h3>
        <p> 这两个定律并不矛盾。从极端角度来说，如果系统中没有可被串行化的代码（即F=1），那么对于这两个定律，其加速比都是1。反之，如果系统中可串行化代码比重达到100%，那么这两个定律得到的加速比都是n（处理器个数）。</p>
    </body>
</html>