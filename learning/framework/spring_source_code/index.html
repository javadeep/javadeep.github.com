<html>
    <head>
        <title>Spring源码深度解析</title>
        <style type="text/css">
            body {
                background-color: #d2b48c;
                margin-left: 10%;
                margin-right: 10%;
                border: 2px dotted black;
                padding: 10px 10px 10px 10px;
                font-family: sans-serif;
            }
        </style>
    </head>
    <body>
        <img src="http://www.kfzimg.com/G03/M00/00/A1/pYYBAFW18oqANcOuAAC4SHZ7D3c673_b.jpg">
        <br><br><br>
        <h1> 目录 </h1>
        <p><a href="./index.html#forword">前言</a></p>
        <p><a href="./index.html#part_1">第一部分 核心实现</a></p>
        <blockquote>
            <p><a href="./index.html#chapter_1">第1章 Spring整体架构和环境搭建</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_1_1">1.1 Spring的整体架构</a></p>
                <p><a href="./index.html#chapter_1_2">1.2 环境搭建</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_2_1">1.2.1 安装GitHub</a></p>
                    <p><a href="./index.html#chapter_1_2_2">1.2.2 安装Gradle</a></p>
                    <p><a href="./index.html#chapter_1_2_3">1.2.3 下载Spring</a></p>
                </blockquote>
            </blockquote>
            <p><a href="./index.html#chapter_2">第2章 容器的基本实现</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_2_1">2.1 容器基本用法</a></p>
                <p><a href="./index.html#chapter_2_2">2.2 功能分析</a></p>
                <p><a href="./index.html#chapter_2_3">2.3 工程搭建</a></p>
                <p><a href="./index.html#chapter_2_4">2.4 Spring的结构组成</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_4_1">2.4.1 beans包的层级结构</a></p>
                    <p><a href="./index.html#chapter_2_4_2">2.4.2 核心类介绍</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_2_5">2.5 容器的基础XmlBeanFactory</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_5_1">2.5.1 配置文件封装</a></p>
                    <p><a href="./index.html#chapter_2_5_2">2.5.2 加载Bean </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_2_6">2.6 获取XML的验证模式 </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_6_1">2.6.1 DTD与XSD区别</a></p>
                    <p><a href="./index.html#chapter_2_6_2">2.6.2 验证模式的读取</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_2_7">2.7 获取Document </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_7_1">2.7.1 EntityResolver用法</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_2_8">2.8 解析及注册BeanDefinitions </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_8_1">2.8.1 profile属性的使用</a></p>
                    <p><a href="./index.html#chapter_2_8_2">2.8.2 解析并注册BeanDefinition</a></p>
                </blockquote>
            </blockquote>
            <p><a href="./index.html#chapter_3">第3章 默认标签的解析</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_3_1">3.1 bean标签的解析及注册</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_3_1_1">3.1.1 解析BeanDefinition</a></p>
                    <p><a href="./index.html#chapter_3_1_2">3.1.2 AbstractBeanDefinition属性</a></p>
                    <p><a href="./index.html#chapter_3_1_3">3.1.3 解析默认标签中的自定义标签元素</a></p>
                    <p><a href="./index.html#chapter_3_1_4">3.1.4 注册解析的BeanDefinition</a></p>
                    <p><a href="./index.html#chapter_3_1_5">3.1.5 通知监听器解析及注册完成</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_3_2">3.2 alias标签的解析</a></p>
                <p><a href="./index.html#chapter_3_3">3.3 Import标签的解析</a></p>
                <p><a href="./index.html#chapter_3_4">3.4 嵌入式beans标签的解析</a></p>
            </blockquote>
            <p><a href="./index.html#chapter_4">第4章 自定义标签的解析</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_4_1">4.1 自定义标签使用</a></p>
            </blockquote>
        </blockquote>
        <br><br><br>
        <h1 id="forword">前言</h1>
        <br><br>
        <h2> 源代码的重要性 </h2>
        <p> 随着各种开源软件的发展，各家都会融合到别家优秀之处来不断完善自己，这样，到最后的结果就是所有的开源软件从设计上或者实现上都会变得越来越相似，也就是说你读完某个优秀源代码后再去读另一个源代码，速度会有很大提升。</p>
        <br><br>
        <h2> 本书特点 </h2>
        <p> 本书完全从开发者的角度去剖析源码，每一章都会提供具有代表性的实例，并以此为基础进行功能实现的分析。</p>
        <br><br>
        <h2> 本书结构 </h2>
        <p> 本书分为两部分：核心实现和企业应用。</p>
        <ul>
            <li> 第一部分：核心实现。是Spring功能的基础，也是企业应用部分的基础，主要对容器以及AOP功能实现做了具体的分析。</li>
            <li> 第二部分：企业应用。在核心实现部分的基础上围绕企业应用常用的模块进行讨论，这些模块包括Spring整合JDBC、Spring整合MyBatis、事务、SpringMVC、远程服务、Spring消息服务等。</li>
        </ul>
        <br><br>
        <h2> 本书适用的Spring版本 </h2>
        <p> 基于Spring 3.2版本 <p>
        <br><br>
        <h2> 感谢 </h2>
        <br><br>
        <h2> 联系作者 </h2>
        <p> haojia_007@163.com </p>
        <br><br><br>
        <h1 id="part_1">第一部分 核心实现</h1>
        <br><br><br>
        <h1 id="chapter_1"> 第1章 Spring整体架构和环境搭建 </h1>
        <p> Spring是为了解决企业应用开发的复杂性而创建的，它使用基本的JavaBean来完成以前只可能由EJB完成的事情。</p>
        <p> 从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。</p>
        <br><br>
        <h2 id="chapter_1_1"> 1.1 Spring的整体架构 </h2>
        <img src="http://i0.sinaimg.cn/IT/cr/2009/0929/3410099300.jpg">
        <ol>
            <li> 
                Core Container
                <p> Core Container（核心容器）包含有Core、Beans、Context和Expression Language模块。</p>
                <p> Core和Beans模块是框架的基础部分，提供IoC（控制器）和依赖注入特性。这里的基础概念是BeanFactory，它提供对Factory模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置。</p>
                <ul>
                    <li> Core模块主要包含Spring框架基本的核心工具类，是其他组件的基本核心。</li>
                    <li> Beans模块是所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control/Dependency Injection（IoC/DI）操作相关的所有类。</li>
                    <li> Context模块构建于Core和Beans模块基础之上，提供一种框架式的对象访问方法。Context模块继承了Beans的特性，为Spring核心提供了大量扩展，添加了对国际化（例如资源绑定）、事件传播、资源加载和对Context的透明创建的支持。Context模块同时也支持J2EE的一些特性。ApplicationContext接口是Context模块的关键。</li>
                    <li> Expression Language模块提供了一个强大的表达式语言用于在运行时查询和操纵对象。它是JSP2.1规范中定义的united expression language的一个扩展。</li>
                </ul>
            </li>
            <li>
                Data Access/Integration
                <p> Data Access/Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块：</p>
                <ul>
                    <li> JDBC模块提供了一个JDBC抽象层，这个模块包含了Spring堆JDBC数据访问进行封装的所有类。</li>
                    <li> ORM模块为流行的对象-关系映射API，提供了一个交互层。</li>
                    <li> OXM模块提供一个对Object/XML映射实现的抽象层。</li>
                    <li> JMS（Java Messaging Service）模块主要包含了一些制造和消费消息的特性。</li>
                    <li> Transaction模块支持编程和声明性的事务管理。</li>
                </ul>
            </li>
            <li>
                Web
                <p> Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。</p>
                <ul>
                    <li> Web模块：提供了基础的面向Web的集成特性。</li>
                    <li> Web-Servlet模块web.servlet.jar：该模块包含Spring的model-view-controller（MVC）实现。</li>
                    <li> Web-Struts模块：该模块提供了对Struts的支持。</li>
                    <li> Web-Porlet模块：提供了用于Portlet环境和Web-Servlet模块的MVC的实现。</li>
                </ul>
            </li>
            <li>
                AOP
                <p> AOP模块提供了一个符合AOP联盟标准的面相切面编程的实现，它让你可以定义例如方法拦截器和切点，从而将逻辑代码分开，降低它们之间的耦合性。</p>
                <ul>
                    <li> Aspects模块提供了对AspectJ的集成支持。</li>
                    <li> Instrumentation模块提供了class instrumentation支持和classloader实现，使得可以在独立的应用服务器上使用。</li>
                </ul>
            </li>
            <li> 
                Test
                <p> Test模块支持使用JUnit和TestNG对Spring组件进行测试。</p>
            </li> 
        </ol>
        <br><br>
        <h2 id="chapter_1_2"> 1.2 环境搭建 </h2>
        <p> 构建Spring源码环境首先要安装GitHub以及Gradle。</p>
        <br>
        <h3 id="chapter_1_2_1"> 1.2.1 安装GitHub </h3>
        <p> 安装Git即可。</p>
        <br>
        <h3 id="chapter_1_2_2"> 1.2.2 安装Gradle </h3>
        <p> idea自带Gradle插件。 </p>
        <br>
        <h3 id="chapter_1_2_3"> 1.2.3 下载Spring </h3>
        <blockquote>
            git clone git://github.com/SpringSource/Spring-framework.git
        </blockquote>
        <p> 导入idea：参考工程中<q>import-into-idea.md</q>进行配置即可。</p>
        <br><br><br>
        <h1 id="chapter_2"> 第2章 容器的基本实现 </h1>
        <br><br>
        <h2 id="chapter_2_1"> 2.1 容器基本用法 </h2>
        <br><br>
        <h2 id="chapter_2_2"> 2.2 功能分析 </h2>
        <p> 完成的功能包括：</p>
        <ol>
            <li> 读取配置文件beanFactoryTest.xml </li>
            <li> 根据beanFactoryTest.xml中配置找到对应的类的配置，并实例化。</li>
            <li> 调用实例化后的实例。</li>
        </ol>
        <p> 如果想完成预想功能，至少需要3个类：</p>
        <ul>
            <li> ConfigReader：用于读取及验证配置文件。</li>
            <li> ReflectionUtil：用于根据配置文件中的配置进行反射实例化。</li>
            <li> App：用于完成整个逻辑的串联。</li>
        </ul>
        <br><br>
        <h2 id="chapter_2_3"> 2.3 工程搭建 </h2>
        <br><br>
        <h2 id="chapter_2_4"> 2.4 Spring的结构组成 </h2>
        <br>
        <h3 id="chapter_2_4_1"> 2.4.1 beans包的层级结构 </h3>
        <p> beans包中的各个源码包的功能如下：</p>
        <ul>
            <li> src/main/java 用于展现Spring的主要逻辑。</li>
            <li> src/main/resources 用于存放系统的配置文件。</li>
            <li> src/test/java 用于对主要逻辑进行单元测试。</li>
            <li> src/test/resources 用于存放测试用的配置文件。</li>
        </ul>
        <br>
        <h3 id="chapter_2_4_2"> 2.4.2 核心类介绍 </h3>
        <h4> 1. DefaultListableBeanFactory </h4>
        <p> XmlBeanFactory继承自DeafultListableBeanFactory，而DefaultListableBeanFactory是整个bean加载的核心部分，是Spring注册及加载bean的默认实现，而对于XmlBeanFactory与DefaultListableBeanFactory不同的地方其实在XmlBeanFactory中使用了自定义的XML读取器XmlBeanDefinitionReader，实现了个性化的BeanDefinitionReader读取，DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory并实现了ConfigurableListableBeanFactory以及BeanDefinitionRegistry接口。相关类图如下：</p>
        <img src="http://img.xue163.com/s2images51cto/wyfs02/M02/7A/6D/wKioL1aokKqQVU02AACmYXZBPO8878.png">
        <ul>
            <li> AliasRegistry：定义对alias的简单增删改等操作。</li>
            <li> SimpleAliasRegistry：主要使用map作为alias的缓存，并对接口AliasRegistry进行实现。</li>
            <li> SingletonBeanRegistry：定义对单例的注册及获取。</li>
            <li> BeanFactory：定义获取bean及bean的各种属性。</li>
            <li> DefaultSingletonBeanRegistry：对接口SingletonBeanRegistry各函数的实现。</li>
            <li> HierarchicalBeanFactory：继承BeanFactory，也就是在BeanFactory定义的功能的基础上增加了对parentFactory的支持。</li>
            <li> BeanDefinitionRegistry：定义对BeanDefinition的各种增删改操作。</li>
            <li> FactoryBeanRegistrySuppoort：在DefaultSingletonBeanRegistry基础上增加了对FactoryBean的特殊处理功能。</li>
            <li> ConfigurableBeanFactory：提供配置Factory的各种方法。</li>
            <li> ListableBeanFactory：根据各种条件获取bean的配置清单。</li>
            <li> AbstractBeanFactory：综合FactoryBeanRegistrySupport和ConfigurableBeanFactory的功能。</li>
            <li> AutowireCapableBeanFactory：提供创建bean、自动注入、初始化以及应用bean的后处理器。</li>
            <li> AbstractAutowireCapableBeanFactory：综合AbstractBeanFactory并对接口AutowireCapableBeanFactory进行实现。</li>
            <li> ConfigurableListableBeanFactory：BeanFactory配置清单、指定忽略类型及接口等。</li>
            <li> DefaultListableBeanFactory：综合上面所有功能，主要是对Bean注册后的处理。</li>
        </ul>
        <p> XmlBeanFactory对DefaultListableBeanFactory类进行了扩展，主要用于从XML文档中读取BeanDefinition，对于注册及获取Bean都是使用从父类DefaultListableBeanFactory类继承的方法去实现，而唯独与父类不同的个性化实现就是增加了XmlBeanDefinitionReader类型的reader属性。在XmlBeanFactory中主要使用reader属性对资源文件进行读取和注册。</p>
        <h4> 2. XmlBeanDefinitionReader </h4>
        <ul>
            <li> ResourceLoader：定义资源加载器，主要应用于根据给定的资源文件地址返回对应的Resource。</li>
            <li> BeanDefinitionReader：主要定义资源文件读取并转换为BeanDefinition的各个功能。</li>
            <li> EnvironmentCapable：定义获取Environment方法。</li>
            <li> DocumentLoader：定义从资源文件加载到转换为Document的功能。</li>
            <li> AbstractBeanDefinitionReader：对EnvironmentCapable、BeanDefinitionReader类定义的功能进行实现。</li>
            <li> BeanDefinitionDocumentReader：定义读取Document并注册BeanDefinition功能。</li>
            <li> BeanDefinitionParserDelegate：定义解析Element的各种方法。</li>
        </ul>
        <p> 在XmlBeanDefinitionReader中主要包含以下几步的处理：</p>
        <ol>
            <li> 通过继承自AbstractBeanDefinitionReader中的方法，来使用ResourceLoader将资源文件路径转换为对应的Resource文件。</li>
            <li> 通过DocumentLoader对Resource文件进行转换，将Resource文件转换为Document文件。</li>
            <li> 通过实现接口BeanDefinitionDocumentReader的DefaultBeanDefinitionDocumentReader类对Document进行解析，并使用BeanDefinitionParserDelegate对Element进行解析。</li>
        </ol>
        <br><br>
        <h2 id="chapter_2_5"> 2.5 容器的基础XmlBeanFactory </h2>
        <blockquote>
            BeanFactory bf = new XmlBeanFactory(new ClassPathResource("beanFactoryTest.xml"));
        </blockquote>
        <p> 上面代码的执行逻辑：</p>
        <blockquote>
            <p> 1. new ClassPathResource("beanFactoryTest.xml") </p>
            <p> 2. resource: Resource </p>
            <p> 3. new XmlBeanFactory(resource) </p>
            <blockquote>
                <p> 3.1 loadBeanDefinitions(resource) </p>
                <p> 3.2 loadBeanDefinitionNum: int </p>
            </blockquote>
        </blockquote>
        <br>
        <h3 id="chapter_2_5_1"> 2.5.1 配置文件封装 </h3> 
        <p> Spring配置文件读取是通过ClassPathResource进行封装的。Spring对其内部使用到的资源实现了自己的抽象结构：Resource接口来封装底层资源。</p>
        <blockquote>
            public interface InputStreamSource { <br>
            <blockquote>
                InputStream getInputStream() throws IOException; <br>
            </blockquote>
            } <br>
            public interface Resource extends InputStreamSource { <br>
            <blockquote>
                boolean exists(); <br>
                boolean isReadable(); <br>
                boolean isOpen(); <br>
                URL getURL() throws IOException; <br>
                URI getURI() throws IOException; <br>
                File getFile() throws IOException; <br>
                long lastModified() throws IOException; <br>
                Resource createRelative(String relativePath) throws IOException; <br>
                String getFilename(); <br>
                String getDescription(); <br>
            </blockquote>
            } <br>
        </blockquote>
        <p> 对不同来源的资源文件都有相应的Resource实现：文件（FileSystemResource）、Classpath资源（ClassPathResource）、URL资源（UrlResource）、InputStream资源（InputStreamResource）、Byte数组（ByteArrayResource）等。</p>
        <p> 在日常的开发工作中，资源文件的加载也是经常用到的，可以直接使用Spring提供的类，比如希望加载文件时可以使用以下代码：</p>
        <blockquote>
            Resource resource = new ClassPathResource("beanFactoryTest.xml"); <br>
            InputStream inputStream = resource.getInputStream(); <br>
        </blockquote>
        <p> 当通过Resource相关类完成了对配置文件进行封装后配置文件的读取工作就全权交给了XmlBeanDefinitionReader来处理了。</p>
        <p> XmlBeanFactory的初始化有若干办法，Spring中提供了很多的构造函数，如：</p>
        <blockquote>
            public XmlBeanFactory(Resource resource) throws BeansException { <br>
            <blockquote>
                // 调用XmlBeanFactory(Resource, BeanFactory)构造方法 <br>
                this(resource, null); <br>
            </blockquote>
            } <br>
            public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException { <br>
            <blockquote>
                super(parentBeanFactory); <br>
                this.reader.loadBeanDefinitions(resource); <br>
            </blockquote>
            } <br>
        </blockquote>
        <p> 上面函数中的代码this.reader.loadBeanDefinitions(resource)才是资源加载的真正实现。</p>
        <p> 在XmlBeanDefinitionReader加载数据前还有一个调用父类构造函数初始化的过程：super(parentBeanFactory)，跟踪代码到父类AbstractAutowireCapableBeanFactory的构造函数中：</p>
        <blockquote>
            public AbstractAutowireCapableBeanFactory() { <br>
            <blockquote>
                super(); <br>
                ignoreDependencyInterface(BeanNameAware.class); <br>
                ignoreDependencyInterface(BeanFactoryAware.class); <br>
                ignoreDependencyInterface(BeanClassLoaderAware.class); <br>
            </blockquote>
            } <br>
        </blockquote>
        <br>
        <h3 id="chapter_2_5_2"> 2.5.2 加载Bean </h3>
        <p> 在XmlBeanFactory构造函数中调用了XmlBeanDefinitionReader类型的reader属性提供的方法this.reader.loadBeanDefinitions(resource)，而这句代码则是整个资源加载的切入点。</p>
        <p> 整个处理过程如下：</p>
        <ol>
            <li> 封装资源文件。当进入XmlBeanDefinitionReader后首先对参数Resource使用EncodedResource类进行封装。</li>
            <li> 获取输入流。从Resource中获取对应的InputStream并构造InputSource。</li>
            <li> 通过构造的InputSource实例和Resource实例继续调用函数doLoadBeanDefinitions。</li>
        </ol>
        <p> loadBeanDefinitions函数具体的实现过程：</p>
        <blockquote>
            public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException { <br>
            <blockquote>
                return loadBeanDefinitions(new EncodedResource(resource)); <br>
            </blockquote>
            } <br>
        </blockquote>
        <p> EncodedResource这个类主要是用于对资源文件的编码进行处理的。其中的主要逻辑体现在getReader()方法中，当设置了编码属性的时候Spring会使用相应的编码作为输入流的编码。</p>
        <blockquote>
            public Reader getReader() throws IOException { <br>
            <blockquote>
                if (this.encoding != null) { <br>
                <blockquote>
                    return new InputStreamReader(this.resource.getInputStream(), this.encoding);
                </blockquote>
                } <br>
                else { <br>
                <blockquote>
                    return new InputStreamReader(this.resource.getInputStream());
                </blockquote>
                } <br>
            </blockquote>
            } <br>
        </blockquote>
        <p> 当构造好encodedResource对象后，再次转入了可复用方法loadBeanDefinitions(new EncodedResource(resource))，这个方法内部才是真正的数据准备阶段。 </p>
        <p> 数据准备阶段逻辑：</p>
        <ul>
            <li> 首先对传入的Resource参数做封装，目的是考虑到Resource可能存在编码要求的情况。</li>
            <li> 其次，通过SAX读取XML文件的方式来准备InputSource对象。</li>
            <li> 最后，将准备的数据通过参数传入真正的核心处理部分doLoadBeanDefinitions(inputSource, encodedResource.getResource())。</li>
        </ul>
        <p> doLoadBeanDefinitions一共做了三件事：</p>
        <ul>
            <li> 获取对XML文件的验证模式（getValidationModeForResource()）。</li>
            <li> 加载XML文件，并得到对应的Document（this.documentLoader.loadDocument()）。</li>
            <li> 根据返回的Document注册Bean信息（registerBeanDefinitions()）。</li>
        </ul>
        <br><br>
        <h2 id="chapter_2_6"> 2.6 获取XML的验证模式 </h2>
        <p> XML文件的验证模式保证了XML文件的正确性，而比较常用的验证模式有两种：DTD和XSD。</p>
        <br>
        <h3 id="chapter_2_6_1"> 2.6.1 DTD与XSD区别 </h3>
        <p> DTD（Document Type Definition）即文档类型定义，是一种XML约束模式语言，是XML文件的验证机制，属于XML文件组成的一部分。DTD是一种保证XML文档格式正确的有效方法，可以通过比较XML文档和DTD文件来看文档是否符合规范，元素和标签使用是否正确。一个DTD文档包含：元素的定义规则，元素间关系的定义规则，元素可使用的属性，可使用的实体或符号规则。</p>
        <p> XML Schema语言就是XSD（XML Schemas Definition）。XML Schema描述了XML文档的结构。可以用一个指定的XML Schema来验证某个XML文档，以检查该XML文档是否符合其要求。文档设计者可以通过XML Schema指定一个XML文档所允许的结构和内容，并可据此检查一个XML文档是否有效的。XML Schema本身是一个XML文档，它符合XML语法结构。可以用通用的XML解析器解析它。</p>
        <br>
        <h3 id="chapter_2_6_2"> 2.6.2 验证模式的读取 </h3>
        <p> Spring通过getValidationModeForResource方法来获取对应资源的验证模式。</p>
        <p> 如果设定了验证模式则使用设定的验证模式（可以通过调用XmlBeanDefinitionReader中的setValidationMode方法进行设定），否则使用自动检测的方式。</p>
        <p> 自动检测验证模式的功能是在函数detectValidationMode方法中实现的，在detectValidationMode函数中又将自动检测验证模式的工作委托给了专门处理类XmlValidationModeDetector，调用了XmlValidationModeDetector的validationModeDector方法。</p>
        <p> Spring用来检测验证模式的办法就是判断是否包含DOCTYPE，如果包含就是DTD，否则就是XSD。</p>
        <br><br>
        <h2 id="chapter_2_7"> 2.7 获取Document </h2>
        <p> XmlBeanFactoryReader类对于文档读取并没有亲力亲为，而是委托给了DocumentLoader去执行，这里的DocumentLoader是个接口，而真正调用的是DefaultDocumentLoader。</p>
        <p> 首先创建DocumentBuilerFactory，再通过DocumentBuilderFactory创建DocumentBuilder，进而解析inputSource来返回Document对象。</p>
        <p> 对于参数entityResolver，传如的是通过getEntityResolver()函数获取的返回值。</p>
        <br>
        <h3 id="chapter_2_7_1"> 2.7.1 EntityResolver用法 </h3>
        <p> EntityResolver的作用是项目本身就可以提供一个如何寻找DTD声明的方法，即由程序来实现寻找DTD声明的过程，这样就避免了通过网络来寻找相应的声明。</p>
        <p> Spring中使用DelegatingEntityResolver类为EntityResolver的实现类。</p>
        <br><br>
        <h2 id="chapter_2_8"> 2.8 解析及注册BeanDefinitions </h2>
        <p> 这个逻辑处理类就是BeanDefinitionDocumentReader。BeanDefinitionDocumentReader是一个接口，而实例化的工作是在createBeanDefinitionDocumentReader()中完成的，通过此方法，BeanDefinitionDocumentReader真正的类型是DefaultBeanDefinitionReader了，进入DefaultBeanDefinitionReader.registerBeanDefinitions()方法，发现最重要的就是提取root，以便再次将root作为参数继续BeanDefinition的注册。</p>
        <p> 到了核心逻辑的底部doRegisterBeanDefinitions(root)，首先是对profile的处理，然后开始进行解析。</p>
        <br>
        <h3 id="chapter_2_8_1"> 2.8.1 profile属性的使用 </h3>
        <p> 该特性可以让我们同时在配置文件中部署两套配置来适用于生产环境和开发环境，这样可以方便的进行切换开发、部署环境，最常用的就是更换不同的数据库。</p>
        <br>
        <h3 id="chapter_2_8_2"> 2.8.2 解析并注册BeanDefinition </h3>
        <p> 处理了profile后就可以进行XML的读取了，跟踪代码进入parseBeanDefinitions(root, this.delegate)。</p>
        <p> Spring的XML配置里面有两大类Bean声明，一个是默认的，如：</p>
        <blockquote>
            &lt;bean id="test" class="test.TestBean"/&gt;
        </blockquote>
        <p> 另一类是自定义的，如：</p>
        <blockquote>
            &lt;tx:annotation-driven/&gt;
        </blockquote>
        <br><br><br>
        <h1 id="chapter_3"> 第3章 默认标签的解析 </h1>
        <p> 默认标签的解析是在parseDefaultElement函数中进行的，函数中分别对4种不同标签（import、alias、bean和beans）做了不同的处理。</p>
        <br><br>
        <h2 id="chapter_3_1"> 3.1 bean标签的解析及注册 </h2>
        <p> 进入函数processBeanDefinition(ele, delegate)，大致逻辑总结如下： </p>
        <ol>
            <li> 首先委托BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析，返回BeanDefinitionHolder类型的实例bdHolder，经过这个方法后，bdHolder实例已经包含我们配置文件中配置的各种属性了，例如class、name、id、alias之类的属性。</li>
            <li> 当返回的bdHolder不为空的情况下若存在默认标签的子节点下再有自定义属性，还需要再次对自定义标签进行解析。BeanDefinitionDelegate类的decorateBeanDefinitionIfRequired方法。</li>
            <li> 解析完成后，需要对解析后的bdHolder进行注册，同样，注册操作委托给了BeanDefinitionReaderUtils的registerBeanDefinition方法。</li>
            <li> 最后发出响应事件，通知相关的监听器，这个bean已经加载完成了。</li>
        </ol>
        <br>
        <h3 id="chapter_3_1_1"> 3.1.1 解析BeanDefinition </h3>
        <p> 进入BeanDefinitionDelegate类的parseBeanDefinitionElement方法：</p>
        <ol>
            <li> 提取元素中的id以及name属性。</li>
            <li> 进一步解析其他所有属性并统一封装至GenericBeanDefinition类型的实例中。</li>
            <li> 如果检测到bean没有指定beanName，那么使用默认规则为此Bean生成beanName。</li>
            <li> 将获取到的信息封装到BeanDefinitionHolder的实例中。</li>
        </ol>
        <p> 进一步查看(2)中的parseBeanDefinitionElement方法：</p>
        <h4> 1. 创建用于属性承载的BeanDefinition </h4>
        <p> BeanDefinition及其实现类：</p>
        <img width="698" height="370" src="http://www.myexception.cn/img/2012/09/19/2336354139.jpg">
        <p> BeanDefinition是一个接口，在Spring中存在三种实现：RootBeanDefinition、ChildBeanDefinition以及GenericBeanDefinition。三种实现均继承了AbstractBeanDefinition，其中BeanDefinition是配置文件&lt;bean&gt;元素标签在容器中的内部表示形式。&lt;bean&gt;元素标签拥有class、scope、lazy-init等配置属性，BeanDefinition则提供了相应的beanClass、scope、lazyInit属性，BeanDefinition和&lt;bean&gt;中的属性一一对应的。其中RootBeanDefinition是最常用的实现类，它对应一般性的&lt;bean&gt;元素标签，GenericBeanDefinition是自2.5版本以后新加入的bean文件配置属性定义类，是一站式服务类。</p>
        <p> 在配置文件中可以定义父&lt;<bean&gt;和子&lt;bean&gt;，父&lt;bean&gt;用RootBeanDefinition表示，而子&lt;bean&gt;用ChildBeanDefinition表示，而没有父&lt;bean&gt;的&lt;bean&gt;就使用RootBeanDefinition表示。AbstractBeanDefinition对两者共同的类信息进行抽象。</p>
        <p> Spring通过BeanDefinition将配置文件中的&lt;bean&gt;转换为容器的内部表示，并将这些BeanDefinition注册到BeanDefinitionRegistry中。Spring容器的BeanDefinitionRegistry就像是Spring配置信息的内存数据库，主要是以map的形式保存，后续操作直接从BeanDefinitionRegistry中读取配置信息。</p>
        <p> 要解析属性首先要创建用于承载属性的实例，也就是创建GenericBeanDefinition类型的实例。而代码createBeanDefinition(className, parent)的作用就是实现此功能。</p>
        <h4> 2. 解析各种属性 </h4>
        <p> 创建了bean信息的承载实例后，便可以进行bean信息的各种属性解析了，首先进入parseBeanDefinitionAttributes方法。parseBeanDefinitionAttributes方法是对element所有元素属性进行解析。</p>
        <h4> 3. 解析子元素meta </h4>
        <blockquote>
            &lt;bean id="myTestBean" class="bean.MyTestBean"&gt;
            <blockquote>
                &lt;meta key="testStr" value-"aaaaaaaa" /&gt;
            </blockquote>
            &lt;/bean&gt;
        </blockquote>
        <p> 这段代码并不会体现在MyTestBean的属性当中，而是一个额外的声明，当需要使用里面的信息的时候可以通过BeanDefinition的getAttribute(key)方法进行获取。</p>
        <h4> 4. 解析子元素lookup-method </h4>
        <p> 获取器注入，获取器注入是一种特殊的方法注入，它是把一个方法声明为返回类型的bean，但实际要返回的bean是在配置文件里面配置的，此方法可用在设计有些可插拔的功能上，解除程序依赖。</p>
        <h4> 5. 解析子元素replaced-method </h4>
        <p> 这个方法主要是对bean中replaced-method子元素的提取，可以在运行时用新的方法替换现有的方法。与之前的look-up不同的是，replaced-methor不但可以动态地替换返回实体bean，而且还能动态地更改原有方法的逻辑。</p>
        <p> 无论是look-up还是replaced-method都是构造了一个MethodOverride，并最终记录在了AbstractBeanDefinition中的methodOverrides属性中。</p>
        <h4> 6. 解析子元素constructor-arg </h4>
        <p> 对于constructor-arg子元素的解析，Spring是通过parseConstructorArgElements函数来实现的。提取所有constructor-arg，然后进行解析，但是具体的解析却被放置在了另一个函数parseConstructorArgElement中。</p>
        <p> 首先是提取constructor-arg上必要的属性（index、type、name）。</p>
        <p> 如果配置中指定了index属性，那么操作步骤如下：</p>
        <ol>
            <li> 解析constructor-arg的子元素。</li>
            <li> 使用ConstructorArgumentValues.ValueHolder类型来封装解析出来的元素。</li>
            <li> 将type、name和index属性统一并封装在ConstructorArgumentValues.ValueHolder类型中并添加至当前BeanDefinition的constructorArgumentValues的indexedArgumentValues属性中。</li>
        </ol>
        <p> 如果没有指定index属性，那么操作步骤如下：</p>
        <ol>
            <li> 解析constructor-arg的子元素。</li>
            <li> 使用ConstructorArgumentValues.ValueHolder类型来封装解析出来的元素。</li>
            <li> 将type、name和index属性统一并封装在ConstructorArgumentValues.ValueHolder类型中并添加至当前BeanDefinition的constructorArgumentValues的genericArgumentValues属性中。</li>
        </ol>
        <p> 对于是否指定index属性来讲，Spring的处理流程是不同的，关键在于属性信息被保存的位置。</p>
        <p> 进入parsePropertyValue，解析构造函数配置中子元素。对构造函数中属性元素的解析，经历了一下几个过程：</p>
        <ol>
            <li> 略过description或者meta。</li>
            <li> 提取constructor-arg上的ref和value属性，以便于根据规则验证正确性，其规则为在constructor-arg上不存在以下情况。
                <ul>
                    <li> 同时既有ref属性又有value属性。</li>
                    <li> 存在ref属性或者value属性且又有子元素。</li>
                </ul>
            </li>
            <li> ref属性的处理。使用RuntimeBeanReference封装对应的ref名称。</li>
            <li> value属性的处理。使用TypedStringValue封装。</li>
            <li> 子元素的处理。parsePropertySubElement中实现了对各种子元素的分类处理。</li>
        </ol>
        <h4> 7. 解析子元素property </h4>
        <p> parsePropertyElement函数完成了对property属性的读取，提取所有property的子元素，然后调用parsePropertyElement处理。</p>
        <p> 与构造函数注入方式不同的是将返回值使用PropertyValue进行封装，并记录在了BeanDefinition中的propertyValues属性中。</p>
        <h4> 8. 解析子元素qualifier </h4>
        <p> Spring允许我们通过Qualifier指定注入Bean的名称，来消除自动注入的歧义。</p>
        <br>
        <h3 id="chapter_3_1_2"> 3.1.2 AbstractBeanDefinition属性 </h3>
        <p> GenericBeanDefinition只是子类实现，而大部分的通用属性都保存在了AbstractBeanDefinition中。</p>
        <br>
        <h3 id="chapter_3_1_3"> 3.1.3 解析默认标签中的自定义标签元素 </h3>
        <p> bean自定义类型的解析：bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder) </p>
        <p> 调用decorateBeanDefinitionIfRequired(ele, definitionHolder, null) </p>
        <p> 这里将第三个参数设置为空，第三个参数是父类bean，当对某个嵌套配置进行分析时，这里需要传递父类beanDefinition。分析源码得知这里传递的参数其实是为了使用父类的scope属性，以备子类若没有设置scope时默认使用父类的属性，这里分析的是顶层配置，所以传递null。</p>
        <p> 进一步跟踪分析，可以看到函数分别对元素的所有属性以及子节点进行了decorateIfRequired函数的调用。首先获取属性或者元素的命名空间，以此来判断该元素或者属性是否适用于自定义标签的解析条件，找出自定义类型所对应的NamespaceHandler并进行进一步解析。</p>
        <p> 在decorateBeanDefinitionIfRequired中我们可以看到对于程序默认的标签的处理其实是直接略过的，这里只对自定义的标签或者说对bean的自定义属性感兴趣。在方法中实现了寻找自定义标签并根据自定义标签寻找命名空间处理器，并进行进一步的解析。</p>
        <br>
        <h3 id="chapter_3_1_4"> 3.1.4 注册解析的BeanDefinition </h3>
        <p> processBeanDefinition函数中的BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry())代码，从代码可以看出，解析的beanDefinition都会被注册到BeanDefinitionRegistry类型的实例registry中，而对于beanDefinition的注册分成了两部分：通过beanName的注册以及通过别名的注册。 </p>
        <h4> 1. 通过beanName注册BeanDefinition </h4>
        <p> 在对于bean的注册处理方式上，主要进行了几个步骤：</p>
        <ol>
            <li> 对AbstractBeanDefinition的校验。主要是对于AbstractBeanDefinition属性中的methodOverrides校验，校验methodOverrides是否与工厂方法并存或者methodOverrides对应的方法根本不存在。</li>
            <li> 对beanName已经注册的情况的处理。如果设置了不允许bean的覆盖，则需要抛出异常，否则直接覆盖。</li>
            <li> 加入map缓存。</li>
            <li> 清除解析之前留下的对应beanName的缓存。</li>
        </ol>
        <h4> 2. 通过别名注册BeanDefinition </h4>
        <p> 注册alias的步骤如下：</p>
        <ol>
            <li> alias与beanName相同情况处理。若alias与beanName名称相同则不需要处理并删除原有alias。</li>
            <li> alias覆盖处理。如果alias不允许被覆盖则抛出异常。</li>
            <li> alias循环检查。当A->B存在时，若再次出现A->C->B时候则会抛出异常。</li>
            <li> 注册alias。</li>
        </ol>
        <br>
        <h3 id="chapter_3_1_5"> 3.1.5 通知监听器解析并注册完成 </h3>
        <p> 通过代码getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder))完成此工作，这里的实现只为扩展，当程序开发人员需要对注册BeanDefinition事件进行监听时可以通过注册监听器的方式并将处理逻辑写入监听器中，目前在Spring中并没有对此事件做任何逻辑处理。</p>
        <br><br>
        <h2 id="chapter_3_2"> 3.2 alias标签的解析 </h2>
        <p> 在对bean进行定义时，除了使用id属性来指定名称之外，为了提供多个名称，可以使用alias标签来指定。而所有的这些名称都指向同一个bean，在某些情况下提供别名非常有用，比如为了让应用的每一个组件能更容易地对公共组件进行引用。</p>
        <p> 然而，在定义bean时就指定所有的别名并不是总是恰当的。有时我们期望能在当前位置为那些在别处定义的bean引入别名。在XML配置文件中，可用单独的&lt;alias/&gt;元素来完成bean别名的定义。</p>
        <br><br>
        <h2 id="chapter_3_3"> 3.3 Import标签的解析 </h2>
        <p> 在解析&lt;import&gt;标签时，Spring进行解析的步骤大致如下：</p>
        <ol>
            <li> 获取resource属性所表示的路径。</li>
            <li> 解析路径中的系统属性，格式如"${user.dir}"。</li>
            <li> 判定location是绝对路径还是相对路径。</li>
            <li> 如果是绝对路径则递归调用bean的解析过程，进行另一次的解析。</li>
            <li> 如果是相对路径则计算出绝对路径并进行解析。</li>
            <li> 通知监听器，解析完成。</li>
        </ol>
        <br><br>
        <h2 id="chapter_3_4"> 3.4 嵌入式beans标签的解析 </h2>
        <p> 对于嵌入式beans标签来讲，与单独的配置文件并没有太大的差别。无非是递归调用beans的解析过程。</p>
        <br><br><br>
        <h1 id="chapter_4"> 第4章 自定义标签的解析 </h1>
        <p> delegate.parseCustomElement(root) </p>
        <br><br>
        <h2 id="chapter_4_1"> 4.1 自定义标签使用 </h2>
        <p> 扩展Spring自定义标签配置大致需要以下几个步骤：</p>
        <ul>
            <li> 创建一个需要扩展的组件。</li>
            <li> 定义一个XSD文件描述组件内容。</li>
            <li> 创建一个文件，实现BeanDefinitionParser接口，用来解析XSD文件中的定义和组件定义。</li>
            <li> 创建一个Handler文件，扩展自NamespaceHandlerSupport，目的是将组件注册到Spring容器。</li>
            <li> 编写Spring.handlers和Spring.schemas文件。</li>
        </ul>
    </body>
</html>