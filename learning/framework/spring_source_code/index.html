<html>
    <head>
        <title>Spring源码深度解析</title>
        <style type="text/css">
            body {
                background-color: #d2b48c;
                margin-left: 10%;
                margin-right: 10%;
                border: 2px dotted black;
                padding: 10px 10px 10px 10px;
                font-family: sans-serif;
            }
        </style>
    </head>
    <body>
        <img src="http://www.kfzimg.com/G03/M00/00/A1/pYYBAFW18oqANcOuAAC4SHZ7D3c673_b.jpg">
        <br><br><br>
        <h1> 目录 </h1>
        <p><a href="./index.html#forword">前言</a></p>
        <p><a href="./index.html#part_1">第一部分 核心实现</a></p>
        <blockquote>
            <p><a href="./index.html#chapter_1">第1章 Spring整体架构和环境搭建</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_1_1">1.1 Spring的整体架构</a></p>
                <p><a href="./index.html#chapter_1_2">1.2 环境搭建</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_1_2_1">1.2.1 安装GitHub</a></p>
                    <p><a href="./index.html#chapter_1_2_2">1.2.2 安装Gradle</a></p>
                    <p><a href="./index.html#chapter_1_2_3">1.2.3 下载Spring</a></p>
                </blockquote>
            </blockquote>
            <p><a href="./index.html#chapter_2">第2章 容器的基本实现</a></p>
            <blockquote>
                <p><a href="./index.html#chapter_2_1">2.1 容器基本用法</a></p>
                <p><a href="./index.html#chapter_2_2">2.2 功能分析</a></p>
                <p><a href="./index.html#chapter_2_3">2.3 工程搭建</a></p>
                <p><a href="./index.html#chapter_2_4">2.4 Spring的结构组成</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_4_1">2.4.1 beans包的层级结构</a></p>
                    <p><a href="./index.html#chapter_2_4_2">2.4.2 核心类介绍</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_2_5">2.5 容器的基础XmlBeanFactory</a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_5_1">2.5.1 配置文件封装</a></p>
                    <p><a href="./index.html#chapter_2_5_2">2.5.2 加载Bean </a></p>
                </blockquote>
                <p><a href="./index.html#chapter_2_6">2.6 获取XML的验证模式 </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_6_1">2.6.1 DTD与XSD区别</a></p>
                    <p><a href="./index.html#chapter_2_6_2">2.6.2 验证模式的读取</a></p>
                </blockquote>
                <p><a href="./index.html#chapter_2_7">2.7 获取Document </a></p>
                <blockquote>
                    <p><a href="./index.html#chapter_2_7_1">2.7.1 EntityResolver用法</a></p>
                </blockquote>
            </blockquote>
        </blockquote>
        <br><br><br>
        <h1 id="forword">前言</h1>
        <br><br>
        <h2> 源代码的重要性 </h2>
        <p> 随着各种开源软件的发展，各家都会融合到别家优秀之处来不断完善自己，这样，到最后的结果就是所有的开源软件从设计上或者实现上都会变得越来越相似，也就是说你读完某个优秀源代码后再去读另一个源代码，速度会有很大提升。</p>
        <br><br>
        <h2> 本书特点 </h2>
        <p> 本书完全从开发者的角度去剖析源码，每一章都会提供具有代表性的实例，并以此为基础进行功能实现的分析。</p>
        <br><br>
        <h2> 本书结构 </h2>
        <p> 本书分为两部分：核心实现和企业应用。</p>
        <ul>
            <li> 第一部分：核心实现。是Spring功能的基础，也是企业应用部分的基础，主要对容器以及AOP功能实现做了具体的分析。</li>
            <li> 第二部分：企业应用。在核心实现部分的基础上围绕企业应用常用的模块进行讨论，这些模块包括Spring整合JDBC、Spring整合MyBatis、事务、SpringMVC、远程服务、Spring消息服务等。</li>
        </ul>
        <br><br>
        <h2> 本书适用的Spring版本 </h2>
        <p> 基于Spring 3.2版本 <p>
        <br><br>
        <h2> 感谢 </h2>
        <br><br>
        <h2> 联系作者 </h2>
        <p> haojia_007@163.com </p>
        <br><br><br>
        <h1 id="part_1">第一部分 核心实现</h1>
        <br><br><br>
        <h1 id="chapter_1"> 第1章 Spring整体架构和环境搭建 </h1>
        <p> Spring是为了解决企业应用开发的复杂性而创建的，它使用基本的JavaBean来完成以前只可能由EJB完成的事情。</p>
        <p> 从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。</p>
        <br><br>
        <h2 id="chapter_1_1"> 1.1 Spring的整体架构 </h2>
        <img src="http://i0.sinaimg.cn/IT/cr/2009/0929/3410099300.jpg">
        <ol>
            <li> 
                Core Container
                <p> Core Container（核心容器）包含有Core、Beans、Context和Expression Language模块。</p>
                <p> Core和Beans模块是框架的基础部分，提供IoC（控制器）和依赖注入特性。这里的基础概念是BeanFactory，它提供对Factory模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置。</p>
                <ul>
                    <li> Core模块主要包含Spring框架基本的核心工具类，是其他组件的基本核心。</li>
                    <li> Beans模块是所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control/Dependency Injection（IoC/DI）操作相关的所有类。</li>
                    <li> Context模块构建于Core和Beans模块基础之上，提供一种框架式的对象访问方法。Context模块继承了Beans的特性，为Spring核心提供了大量扩展，添加了对国际化（例如资源绑定）、事件传播、资源加载和对Context的透明创建的支持。Context模块同时也支持J2EE的一些特性。ApplicationContext接口是Context模块的关键。</li>
                    <li> Expression Language模块提供了一个强大的表达式语言用于在运行时查询和操纵对象。它是JSP2.1规范中定义的united expression language的一个扩展。</li>
                </ul>
            </li>
            <li>
                Data Access/Integration
                <p> Data Access/Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块：</p>
                <ul>
                    <li> JDBC模块提供了一个JDBC抽象层，这个模块包含了Spring堆JDBC数据访问进行封装的所有类。</li>
                    <li> ORM模块为流行的对象-关系映射API，提供了一个交互层。</li>
                    <li> OXM模块提供一个对Object/XML映射实现的抽象层。</li>
                    <li> JMS（Java Messaging Service）模块主要包含了一些制造和消费消息的特性。</li>
                    <li> Transaction模块支持编程和声明性的事务管理。</li>
                </ul>
            </li>
            <li>
                Web
                <p> Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。</p>
                <ul>
                    <li> Web模块：提供了基础的面向Web的集成特性。</li>
                    <li> Web-Servlet模块web.servlet.jar：该模块包含Spring的model-view-controller（MVC）实现。</li>
                    <li> Web-Struts模块：该模块提供了对Struts的支持。</li>
                    <li> Web-Porlet模块：提供了用于Portlet环境和Web-Servlet模块的MVC的实现。</li>
                </ul>
            </li>
            <li>
                AOP
                <p> AOP模块提供了一个符合AOP联盟标准的面相切面编程的实现，它让你可以定义例如方法拦截器和切点，从而将逻辑代码分开，降低它们之间的耦合性。</p>
                <ul>
                    <li> Aspects模块提供了对AspectJ的集成支持。</li>
                    <li> Instrumentation模块提供了class instrumentation支持和classloader实现，使得可以在独立的应用服务器上使用。</li>
                </ul>
            </li>
            <li> 
                Test
                <p> Test模块支持使用JUnit和TestNG对Spring组件进行测试。</p>
            </li> 
        </ol>
        <br><br>
        <h2 id="chapter_1_2"> 1.2 环境搭建 </h2>
        <p> 构建Spring源码环境首先要安装GitHub以及Gradle。</p>
        <br>
        <h3 id="chapter_1_2_1"> 1.2.1 安装GitHub </h3>
        <p> 安装Git即可。</p>
        <br>
        <h3 id="chapter_1_2_2"> 1.2.2 安装Gradle </h3>
        <p> idea自带Gradle插件。 </p>
        <br>
        <h3 id="chapter_1_2_3"> 1.2.3 下载Spring </h3>
        <blockquote>
            git clone git://github.com/SpringSource/Spring-framework.git
        </blockquote>
        <p> 导入idea：参考工程中<q>import-into-idea.md</q>进行配置即可。</p>
        <br><br><br>
        <h1 id="chapter_2"> 第2章 容器的基本实现 </h1>
        <br><br>
        <h2 id="chapter_2_1"> 2.1 容器基本用法 </h2>
        <br><br>
        <h2 id="chapter_2_2"> 2.2 功能分析 </h2>
        <p> 完成的功能包括：</p>
        <ol>
            <li> 读取配置文件beanFactoryTest.xml </li>
            <li> 根据beanFactoryTest.xml中配置找到对应的类的配置，并实例化。</li>
            <li> 调用实例化后的实例。</li>
        </ol>
        <p> 如果想完成预想功能，至少需要3个类：</p>
        <ul>
            <li> ConfigReader：用于读取及验证配置文件。</li>
            <li> ReflectionUtil：用于根据配置文件中的配置进行反射实例化。</li>
            <li> App：用于完成整个逻辑的串联。</li>
        </ul>
        <br><br>
        <h2 id="chapter_2_3"> 2.3 工程搭建 </h2>
        <br><br>
        <h2 id="chapter_2_4"> 2.4 Spring的结构组成 </h2>
        <br>
        <h3 id="chapter_2_4_1"> 2.4.1 beans包的层级结构 </h3>
        <p> beans包中的各个源码包的功能如下：</p>
        <ul>
            <li> src/main/java 用于展现Spring的主要逻辑。</li>
            <li> src/main/resources 用于存放系统的配置文件。</li>
            <li> src/test/java 用于对主要逻辑进行单元测试。</li>
            <li> src/test/resources 用于存放测试用的配置文件。</li>
        </ul>
        <br>
        <h3 id="chapter_2_4_2"> 2.4.2 核心类介绍 </h3>
        <h4> 1. DefaultListableBeanFactory </h4>
        <p> XmlBeanFactory继承自DeafultListableBeanFactory，而DefaultListableBeanFactory是整个bean加载的核心部分，是Spring注册及加载bean的默认实现，而对于XmlBeanFactory与DefaultListableBeanFactory不同的地方其实在XmlBeanFactory中使用了自定义的XML读取器XmlBeanDefinitionReader，实现了个性化的BeanDefinitionReader读取，DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory并实现了ConfigurableListableBeanFactory以及BeanDefinitionRegistry接口。相关类图如下：</p>
        <img src="http://img.xue163.com/s2images51cto/wyfs02/M02/7A/6D/wKioL1aokKqQVU02AACmYXZBPO8878.png">
        <ul>
            <li> AliasRegistry：定义对alias的简单增删改等操作。</li>
            <li> SimpleAliasRegistry：主要使用map作为alias的缓存，并对接口AliasRegistry进行实现。</li>
            <li> SingletonBeanRegistry：定义对单例的注册及获取。</li>
            <li> BeanFactory：定义获取bean及bean的各种属性。</li>
            <li> DefaultSingletonBeanRegistry：对接口SingletonBeanRegistry各函数的实现。</li>
            <li> HierarchicalBeanFactory：继承BeanFactory，也就是在BeanFactory定义的功能的基础上增加了对parentFactory的支持。</li>
            <li> BeanDefinitionRegistry：定义对BeanDefinition的各种增删改操作。</li>
            <li> FactoryBeanRegistrySuppoort：在DefaultSingletonBeanRegistry基础上增加了对FactoryBean的特殊处理功能。</li>
            <li> ConfigurableBeanFactory：提供配置Factory的各种方法。</li>
            <li> ListableBeanFactory：根据各种条件获取bean的配置清单。</li>
            <li> AbstractBeanFactory：综合FactoryBeanRegistrySupport和ConfigurableBeanFactory的功能。</li>
            <li> AutowireCapableBeanFactory：提供创建bean、自动注入、初始化以及应用bean的后处理器。</li>
            <li> AbstractAutowireCapableBeanFactory：综合AbstractBeanFactory并对接口AutowireCapableBeanFactory进行实现。</li>
            <li> ConfigurableListableBeanFactory：BeanFactory配置清单、指定忽略类型及接口等。</li>
            <li> DefaultListableBeanFactory：综合上面所有功能，主要是对Bean注册后的处理。</li>
        </ul>
        <p> XmlBeanFactory对DefaultListableBeanFactory类进行了扩展，主要用于从XML文档中读取BeanDefinition，对于注册及获取Bean都是使用从父类DefaultListableBeanFactory类继承的方法去实现，而唯独与父类不同的个性化实现就是增加了XmlBeanDefinitionReader类型的reader属性。在XmlBeanFactory中主要使用reader属性对资源文件进行读取和注册。</p>
        <h4> 2. XmlBeanDefinitionReader </h4>
        <ul>
            <li> ResourceLoader：定义资源加载器，主要应用于根据给定的资源文件地址返回对应的Resource。</li>
            <li> BeanDefinitionReader：主要定义资源文件读取并转换为BeanDefinition的各个功能。</li>
            <li> EnvironmentCapable：定义获取Environment方法。</li>
            <li> DocumentLoader：定义从资源文件加载到转换为Document的功能。</li>
            <li> AbstractBeanDefinitionReader：对EnvironmentCapable、BeanDefinitionReader类定义的功能进行实现。</li>
            <li> BeanDefinitionDocumentReader：定义读取Document并注册BeanDefinition功能。</li>
            <li> BeanDefinitionParserDelegate：定义解析Element的各种方法。</li>
        </ul>
        <p> 在XmlBeanDefinitionReader中主要包含以下几步的处理：</p>
        <ol>
            <li> 通过继承自AbstractBeanDefinitionReader中的方法，来使用ResourceLoader将资源文件路径转换为对应的Resource文件。</li>
            <li> 通过DocumentLoader对Resource文件进行转换，将Resource文件转换为Document文件。</li>
            <li> 通过实现接口BeanDefinitionDocumentReader的DefaultBeanDefinitionDocumentReader类对Document进行解析，并使用BeanDefinitionParserDelegate对Element进行解析。</li>
        </ol>
        <br><br>
        <h2 id="chapter_2_5"> 2.5 容器的基础XmlBeanFactory </h2>
        <blockquote>
            BeanFactory bf = new XmlBeanFactory(new ClassPathResource("beanFactoryTest.xml"));
        </blockquote>
        <p> 上面代码的执行逻辑：</p>
        <blockquote>
            <p> 1. new ClassPathResource("beanFactoryTest.xml") </p>
            <p> 2. resource: Resource </p>
            <p> 3. new XmlBeanFactory(resource) </p>
            <blockquote>
                <p> 3.1 loadBeanDefinitions(resource) </p>
                <p> 3.2 loadBeanDefinitionNum: int </p>
            </blockquote>
        </blockquote>
        <br>
        <h3 id="chapter_2_5_1"> 2.5.1 配置文件封装 </h3> 
        <p> Spring配置文件读取是通过ClassPathResource进行封装的。Spring对其内部使用到的资源实现了自己的抽象结构：Resource接口来封装底层资源。</p>
        <blockquote>
            public interface InputStreamSource { <br>
            <blockquote>
                InputStream getInputStream() throws IOException; <br>
            </blockquote>
            } <br>
            public interface Resource extends InputStreamSource { <br>
            <blockquote>
                boolean exists(); <br>
                boolean isReadable(); <br>
                boolean isOpen(); <br>
                URL getURL() throws IOException; <br>
                URI getURI() throws IOException; <br>
                File getFile() throws IOException; <br>
                long lastModified() throws IOException; <br>
                Resource createRelative(String relativePath) throws IOException; <br>
                String getFilename(); <br>
                String getDescription(); <br>
            </blockquote>
            } <br>
        </blockquote>
        <p> 对不同来源的资源文件都有相应的Resource实现：文件（FileSystemResource）、Classpath资源（ClassPathResource）、URL资源（UrlResource）、InputStream资源（InputStreamResource）、Byte数组（ByteArrayResource）等。</p>
        <p> 在日常的开发工作中，资源文件的加载也是经常用到的，可以直接使用Spring提供的类，比如希望加载文件时可以使用以下代码：</p>
        <blockquote>
            Resource resource = new ClassPathResource("beanFactoryTest.xml"); <br>
            InputStream inputStream = resource.getInputStream(); <br>
        </blockquote>
        <p> 当通过Resource相关类完成了对配置文件进行封装后配置文件的读取工作就全权交给了XmlBeanDefinitionReader来处理了。</p>
        <p> XmlBeanFactory的初始化有若干办法，Spring中提供了很多的构造函数，如：</p>
        <blockquote>
            public XmlBeanFactory(Resource resource) throws BeansException { <br>
            <blockquote>
                // 调用XmlBeanFactory(Resource, BeanFactory)构造方法 <br>
                this(resource, null); <br>
            </blockquote>
            } <br>
            public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException { <br>
            <blockquote>
                super(parentBeanFactory); <br>
                this.reader.loadBeanDefinitions(resource); <br>
            </blockquote>
            } <br>
        </blockquote>
        <p> 上面函数中的代码this.reader.loadBeanDefinitions(resource)才是资源加载的真正实现。</p>
        <p> 在XmlBeanDefinitionReader加载数据前还有一个调用父类构造函数初始化的过程：super(parentBeanFactory)，跟踪代码到父类AbstractAutowireCapableBeanFactory的构造函数中：</p>
        <blockquote>
            public AbstractAutowireCapableBeanFactory() { <br>
            <blockquote>
                super(); <br>
                ignoreDependencyInterface(BeanNameAware.class); <br>
                ignoreDependencyInterface(BeanFactoryAware.class); <br>
                ignoreDependencyInterface(BeanClassLoaderAware.class); <br>
            </blockquote>
            } <br>
        </blockquote>
        <br>
        <h3 id="chapter_2_5_2"> 2.5.2 加载Bean </h3>
        <p> 在XmlBeanFactory构造函数中调用了XmlBeanDefinitionReader类型的reader属性提供的方法this.reader.loadBeanDefinitions(resource)，而这句代码则是整个资源加载的切入点。</p>
        <p> 整个处理过程如下：</p>
        <ol>
            <li> 封装资源文件。当进入XmlBeanDefinitionReader后首先对参数Resource使用EncodedResource类进行封装。</li>
            <li> 获取输入流。从Resource中获取对应的InputStream并构造InputSource。</li>
            <li> 通过构造的InputSource实例和Resource实例继续调用函数doLoadBeanDefinitions。</li>
        </ol>
        <p> loadBeanDefinitions函数具体的实现过程：</p>
        <blockquote>
            public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException { <br>
            <blockquote>
                return loadBeanDefinitions(new EncodedResource(resource)); <br>
            </blockquote>
            } <br>
        </blockquote>
        <p> EncodedResource这个类主要是用于对资源文件的编码进行处理的。其中的主要逻辑体现在getReader()方法中，当设置了编码属性的时候Spring会使用相应的编码作为输入流的编码。</p>
        <blockquote>
            public Reader getReader() throws IOException { <br>
            <blockquote>
                if (this.encoding != null) { <br>
                <blockquote>
                    return new InputStreamReader(this.resource.getInputStream(), this.encoding);
                </blockquote>
                } <br>
                else { <br>
                <blockquote>
                    return new InputStreamReader(this.resource.getInputStream());
                </blockquote>
                } <br>
            </blockquote>
            } <br>
        </blockquote>
        <p> 当构造好encodedResource对象后，再次转入了可复用方法loadBeanDefinitions(new EncodedResource(resource))，这个方法内部才是真正的数据准备阶段。 </p>
        <p> 数据准备阶段逻辑：</p>
        <ul>
            <li> 首先对传入的Resource参数做封装，目的是考虑到Resource可能存在编码要求的情况。</li>
            <li> 其次，通过SAX读取XML文件的方式来准备InputSource对象。</li>
            <li> 最后，将准备的数据通过参数传入真正的核心处理部分doLoadBeanDefinitions(inputSource, encodedResource.getResource())。</li>
        </ul>
        <p> doLoadBeanDefinitions一共做了三件事：</p>
        <ul>
            <li> 获取对XML文件的验证模式（getValidationModeForResource()）。</li>
            <li> 加载XML文件，并得到对应的Document（this.documentLoader.loadDocument()）。</li>
            <li> 根据返回的Document注册Bean信息（registerBeanDefinitions()）。</li>
        </ul>
        <br><br>
        <h2 id="chapter_2_6"> 2.6 获取XML的验证模式 </h2>
        <p> XML文件的验证模式保证了XML文件的正确性，而比较常用的验证模式有两种：DTD和XSD。</p>
        <br>
        <h3 id="chapter_2_6_1"> 2.6.1 DTD与XSD区别 </h3>
        <p> DTD（Document Type Definition）即文档类型定义，是一种XML约束模式语言，是XML文件的验证机制，属于XML文件组成的一部分。DTD是一种保证XML文档格式正确的有效方法，可以通过比较XML文档和DTD文件来看文档是否符合规范，元素和标签使用是否正确。一个DTD文档包含：元素的定义规则，元素间关系的定义规则，元素可使用的属性，可使用的实体或符号规则。</p>
        <p> XML Schema语言就是XSD（XML Schemas Definition）。XML Schema描述了XML文档的结构。可以用一个指定的XML Schema来验证某个XML文档，以检查该XML文档是否符合其要求。文档设计者可以通过XML Schema指定一个XML文档所允许的结构和内容，并可据此检查一个XML文档是否有效的。XML Schema本身是一个XML文档，它符合XML语法结构。可以用通用的XML解析器解析它。</p>
        <br>
        <h3 id="chapter_2_6_2"> 2.6.2 验证模式的读取 </h3>
        <p> Spring通过getValidationModeForResource方法来获取对应资源的验证模式。</p>
        <p> 如果设定了验证模式则使用设定的验证模式（可以通过调用XmlBeanDefinitionReader中的setValidationMode方法进行设定），否则使用自动检测的方式。</p>
        <p> 自动检测验证模式的功能是在函数detectValidationMode方法中实现的，在detectValidationMode函数中又将自动检测验证模式的工作委托给了专门处理类XmlValidationModeDetector，调用了XmlValidationModeDetector的validationModeDector方法。</p>
        <p> Spring用来检测验证模式的办法就是判断是否包含DOCTYPE，如果包含就是DTD，否则就是XSD。</p>
        <br><br>
        <h2 id="chapter_2_7"> 2.7 获取Document </h2>
        <p> XmlBeanFactoryReader类对于文档读取并没有亲力亲为，而是委托给了DocumentLoader去执行，这里的DocumentLoader是个接口，而真正调用的是DefaultDocumentLoader。</p>
        <p> 首先创建DocumentBuilerFactory，再通过DocumentBuilderFactory创建DocumentBuilder，进而解析inputSource来返回Document对象。</p>
        <p> 对于参数entityResolver，传如的是通过getEntityResolver()函数获取的返回值。</p>
        <br>
        <h3 id="chapter_2_7_1"> 2.7.1 EntityResolver用法 </h3>
        <p> EntityResolver的作用是项目本身就可以提供一个如何寻找DTD声明的方法，即由程序来实现寻找DTD声明的过程，这样就避免了通过网络来寻找相应的声明。</p>
        <p> Spring中使用DelegatingEntityResolver类为EntityResolver的实现类。</p>
    </body>
</html>